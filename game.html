<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éœ“è™¹ç‰Œ - å°æˆ°</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
</head>

<body>
    <!-- Animation Overlay -->
    <div class="animation-overlay hidden" id="animationOverlay"></div>

    <!-- Card Selection Phase -->
    <div class="selection-phase hidden" id="selectionPhase">
        <h2 class="selection-title" id="selectionTitle">ç©å®¶1 æŠ½ç‰Œéšæ®µ</h2>
        <p class="selection-subtitle" id="selectionSubtitle">é¸æ“‡ä¸€å¼µç‰Œæ”¾å…¥æˆ°é¬¥å€</p>
        <div class="drawn-cards" id="drawnCards"></div>
        <div class="selection-info" id="selectionInfo"></div>
        <button class="btn confirm-selection" id="confirmSelection" disabled>ç¢ºèªé¸æ“‡</button>
    </div>

    <!-- Battle Screen -->
    <div class="battle-container" id="battleContainer">
        <!-- Player 1 Area (Left / Top) -->
        <div class="player-area player1" id="player1Area">
            <div class="player-header glass">
                <span class="player-name">ç©å®¶1</span>
                <span class="turn-badge hidden" id="p1TurnBadge">ä½ çš„å›åˆ</span>
            </div>

            <div class="battle-card glass" id="p1BattleCard">
                <div class="battle-card-header">
                    <span class="battle-char-name" id="p1CharName">-</span>
                    <span class="battle-char-rarity" id="p1CharRarity">-</span>
                </div>

                <div class="hp-bar-container">
                    <div class="bar-wrapper">
                        <div class="shield-bar" id="p1ShieldBar" style="width: 0%"></div>
                        <div class="hp-bar" id="p1HpBar" style="width: 100%"></div>
                        <div class="bar-text" id="p1HpText">100 / 100</div>
                    </div>
                </div>

                <div class="stats-row">
                    <span class="stat stat-atk">âš” ATK: <span id="p1Atk">0</span></span>
                    <span class="stat">ğŸ›¡ è­·ç›¾: <span id="p1Shield">0</span></span>
                </div>

                <div class="status-effects" id="p1Status"></div>
                <div class="passive-info" id="p1Passive"></div>


                <div class="action-buttons" id="p1Actions">
                    <button class="btn action-btn attack-btn" onclick="doAction('attack')">æ™®æ”»</button>
                    <button class="btn action-btn skill-btn-main" id="p1SkillBtn"
                        onclick="openSkillModal('player1')">ä½¿ç”¨æŠ€èƒ½</button>
                    <button class="btn action-btn retreat-btn" onclick="showRetreat()">æ’¤é€€</button>
                </div>
            </div>

            <div class="standby-area glass">
                <div class="standby-title">å‚™æˆ°å€</div>
                <div class="standby-cards" id="p1Standby"></div>
            </div>
        </div>

        <!-- Center Battle Info -->
        <div class="battle-center glass">
            <div class="turn-indicator" id="turnIndicator">
                å›åˆ <span id="turnCount">0</span>
            </div>
            <button class="btn btn-magenta mobile-toggle-btn" id="mobileToggleBtn"
                onclick="toggleMobileView()">æŸ¥çœ‹å°æ‰‹</button>
            <div class="battle-log" id="battleLog"></div>
        </div>

        <!-- Player 2 Area (Right / Bottom) -->
        <div class="player-area player2" id="player2Area">
            <div class="player-header glass">
                <span class="player-name">ç©å®¶2</span>
                <span class="thinking-indicator hidden" id="npcThinking"
                    style="margin-left: 10px; color: var(--neon-cyan); font-size: 0.9rem;">
                    æ€è€ƒä¸­<span class="thinking-dots"><span>.</span><span>.</span><span>.</span></span>
                </span>
                <span class="turn-badge hidden" id="p2TurnBadge">ä½ çš„å›åˆ</span>
            </div>

            <div class="battle-card glass" id="p2BattleCard">
                <div class="battle-card-header">
                    <span class="battle-char-name" id="p2CharName">-</span>
                    <span class="battle-char-rarity" id="p2CharRarity">-</span>
                </div>

                <div class="hp-bar-container">
                    <div class="bar-wrapper">
                        <div class="shield-bar" id="p2ShieldBar" style="width: 0%"></div>
                        <div class="hp-bar" id="p2HpBar" style="width: 100%"></div>
                        <div class="bar-text" id="p2HpText">100 / 100</div>
                    </div>
                </div>

                <div class="stats-row">
                    <span class="stat stat-atk">âš” ATK: <span id="p2Atk">0</span></span>
                    <span class="stat">ğŸ›¡ è­·ç›¾: <span id="p2Shield">0</span></span>
                </div>

                <div class="status-effects" id="p2Status"></div>
                <div class="passive-info" id="p2Passive"></div>


                <div class="action-buttons" id="p2Actions">
                    <button class="btn action-btn attack-btn" onclick="doAction('attack')">æ™®æ”»</button>
                    <button class="btn action-btn skill-btn-main" id="p2SkillBtn"
                        onclick="openSkillModal('player2')">ä½¿ç”¨æŠ€èƒ½</button>
                    <button class="btn action-btn retreat-btn" onclick="showRetreat()">æ’¤é€€</button>
                </div>
            </div>

            <div class="standby-area glass">
                <div class="standby-title">å‚™æˆ°å€</div>
                <div class="standby-cards" id="p2Standby"></div>
            </div>
        </div>
    </div>

    <!-- Replacement Modal (Mandatory death replacement) -->
    <div class="modal-overlay" id="replacementModal">
        <div class="modal glass" style="max-width: 800px;">
            <h2 id="replacementTitle">è§’è‰²å·²é™£äº¡ï¼é¸æ“‡æ›¿æ›ä¸Šå ´çš„è§’è‰²</h2>
            <div id="replacementOptions" class="drawn-cards"></div>
        </div>
    </div>

    <!-- Retreat Modal -->
    <div class="modal-overlay" id="retreatModal">
        <div class="modal glass" style="max-width: 800px;">
            <h2>æ’¤é€€è§’è‰²</h2>
            <p style="margin-bottom: 20px; color: var(--text-secondary);">é¸æ“‡ä¸€å€‹éšŠå‹ä¾†æ›¿æ›ç•¶å‰ä¸Šå ´çš„è§’è‰²</p>
            <div id="retreatOptions" class="drawn-cards"></div>
            <button class="btn" onclick="closeRetreatModal()" style="margin-top: 20px;">å–æ¶ˆ</button>
        </div>
    </div>

    <!-- Skill Panel Modal -->
    <div class="modal-overlay" id="skillPanelModal">
        <div class="modal glass" style="max-width: 800px;">
            <h2 id="skillModalTitle">ä½¿ç”¨æŠ€èƒ½</h2>
            <div id="skillModalOptions" class="skills-container-modal"></div>
            <button class="btn" onclick="closeSkillModal()" style="margin-top: 20px; width: 100%;">è¿”å›</button>
        </div>
    </div>

    <!-- Card Details Modal -->

    <!-- Card Details Modal -->
    <div class="modal-overlay" id="cardDetailsModal">
        <div class="modal glass" id="cardDetailsContent">
            <!-- Content injected via JS -->
        </div>
    </div>

    <!-- Scripts -->
    <script src="js/data/story.js"></script>
    <script src="js/data/characters_part1.js"></script>
    <script src="js/data/characters_part2.js"></script>
    <script src="js/data/characters_part3.js"></script>
    <script src="js/data/characters_part4.js"></script>
    <script src="js/data/characters.js"></script>
    <script src="js/core/gameState.js"></script>
    <script src="js/core/battleSystem.js"></script>
    <script src="js/ui/animations.js"></script>
    <script>
        // Game initialization
        let selectionPhase = 'p1_draw';
        let selectedBattleCard = null;
        let isShowingOpponent = false;

        function toggleMobileView() {
            const container = document.getElementById('battleContainer');
            const btn = document.getElementById('mobileToggleBtn');
            isShowingOpponent = !isShowingOpponent;

            if (isShowingOpponent) {
                container.classList.add('show-opponent-mobile');
                btn.textContent = 'è¿”å›æˆ‘çš„ç•«é¢';
            } else {
                container.classList.remove('show-opponent-mobile');
                btn.textContent = 'æŸ¥çœ‹å°æ‰‹';
            }
        }

        function renderCardInfo(card) {
            let skillsHtml = '';
            if (card.skills && card.skills.length > 0) {
                skillsHtml = '<div style="margin-top: 10px; flex-grow: 1; overflow-y: auto; text-align: left;">';
                card.skills.forEach(skill => {
                    skillsHtml += `<div class="skill-preview" style="margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px;">
                        <div style="color: var(--neon-cyan); font-weight: bold;">â€¢ ${skill.name} <span style="font-size: 0.7rem; color: #888;">(CD:${skill.cd})</span></div>
                        <div style="font-size: 0.8rem; color: #ddd; margin-top: 2px; line-height: 1.3;">${skill.desc || 'ç„¡æè¿°'}</div>
                    </div>`;
                });
                skillsHtml += '</div>';
            }

            return `
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span style="font-size: 0.8rem; color: var(--text-secondary);">#${card.id}</span>
                    <span class="${getRarityClass(card.rarity)}" style="font-size: 0.75rem;">${getRarityName(card.rarity)}</span>
                </div>
                <div style="font-size: 1.3rem; font-weight: bold; margin-bottom: 5px; color: var(--text-primary); text-shadow: 0 0 5px currentColor;">${card.name}</div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 0.9rem; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 4px;">
                    <span style="color: #ff6b6b;">HP: ${card.hp}/${card.maxHp}</span>
                    <span style="color: #ffd93d;">ATK: ${typeof card.atk === 'object' ? `${card.atk.min}-${card.atk.max}` : card.atk}</span>
                </div>
                ${card.passive ? `
                    <div style="font-size: 0.8rem; color: var(--neon-gold); margin-bottom: 8px; text-align: left; background: rgba(255, 215, 0, 0.1); padding: 5px; border-radius: 4px;">
                        <div style="font-weight: bold;">è¢«å‹•: ${card.passive.name}</div>
                        <div style="margin-top: 2px; line-height: 1.2;">${card.passive.desc || 'ç„¡æè¿°'}</div>
                    </div>` : ''}
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px; border-bottom: 1px solid var(--text-secondary);">æŠ€èƒ½:</div>
                ${skillsHtml}
            `;
        }

        async function initGame() {
            const mode = localStorage.getItem('gameMode') || 'classic';
            const type = localStorage.getItem('gameType') || 'pvp';
            const difficulty = localStorage.getItem('pveDifficulty') || 'normal';

            if (mode === 'story') {
                const chapterId = localStorage.getItem('story_current_chapter');
                const nodeIndex = parseInt(localStorage.getItem('story_current_node'), 10);
                GameState.initStoryMode(chapterId, nodeIndex);

                document.getElementById('selectionPhase').classList.remove('hidden');
                document.getElementById('battleContainer').style.display = 'none';

                selectionPhase = 'p1_draw';
                document.getElementById('selectionTitle').textContent = `${GameState.player1.name} é¸æ“‡é¦–ç™¼è§’è‰²`;
                renderSelectionCards('player1', GameState.player1.allCards);
            } else {
                GameState.init(mode, type, difficulty);

                // Coin flip
                const firstPlayer = await Animations.coinFlip();
                GameState.firstPlayer = firstPlayer;
                GameState.currentPlayer = firstPlayer;

                if (type === 'pve') {
                    // Draw cards silently for NPC
                    const npcCards = GameState.drawCards('player2', GameState.getCardCount());
                    if (difficulty === 'hard') {
                        GameState.player2.name = 'NPC (å›°é›£)';
                    } else if (difficulty === 'easy') {
                        GameState.player2.name = 'NPC (ç°¡å–®)';
                    } else {
                        GameState.player2.name = 'NPC';
                    }

                    // NPC selects a random card
                    GameState.setBattleCard('player2', Math.floor(Math.random() * GameState.getCardCount()));

                    // Player 1 draw, regardless of firstPlayer
                    selectionPhase = 'player1_draw';
                    await startDrawPhase('player1');
                } else {
                    // Draw phase for the first player
                    const firstPlayerKey = firstPlayer === 1 ? 'player1' : 'player2';
                    selectionPhase = firstPlayerKey + '_draw';
                    await startDrawPhase(firstPlayerKey);
                }
            }
        }

        async function startDrawPhase(playerKey) {
            const cardCount = GameState.getCardCount();
            const cards = GameState.drawCards(playerKey, cardCount);

            document.getElementById('selectionPhase').classList.remove('hidden');
            document.getElementById('battleContainer').style.display = 'none';

            document.getElementById('selectionTitle').textContent =
                playerKey === 'player1' ? 'ç©å®¶1 æŠ½ç‰Œéšæ®µ' : 'ç©å®¶2 æŠ½ç‰Œéšæ®µ';

            // Show card draw animation
            await Animations.drawCards(cards);

            // Show selection UI
            renderSelectionCards(playerKey, cards);
        }

        function renderSelectionCards(playerKey, cards) {
            const container = document.getElementById('drawnCards');
            container.innerHTML = '';

            cards.forEach((card, idx) => {
                const div = document.createElement('div');
                div.className = `select-card glass ${getRarityClass(card.rarity)}`;
                div.innerHTML = renderCardInfo(card);
                div.onclick = () => selectCard(playerKey, idx);
                container.appendChild(div);
            });

            selectedBattleCard = null;
            updateSelectionInfo();
        }

        function selectCard(playerKey, idx) {
            const cards = document.querySelectorAll('.select-card');
            cards.forEach((c, i) => {
                c.classList.remove('selected-battle');
                if (i === idx) c.classList.add('selected-battle');
            });

            selectedBattleCard = idx;
            updateSelectionInfo();
        }

        function updateSelectionInfo() {
            const btn = document.getElementById('confirmSelection');
            btn.disabled = selectedBattleCard === null;

            document.getElementById('selectionInfo').textContent =
                selectedBattleCard !== null ? 'å·²é¸æ“‡æˆ°é¬¥è§’è‰²' : 'è«‹é¸æ“‡ä¸€å¼µç‰Œä½œç‚ºæˆ°é¬¥è§’è‰²';
        }

        document.getElementById('confirmSelection').onclick = async function () {
            if (selectedBattleCard === null) return;

            const currentPlayerKey = selectionPhase.startsWith('p1') || selectionPhase.startsWith('player1') ? 'player1' : 'player2';
            const otherPlayerKey = currentPlayerKey === 'player1' ? 'player2' : 'player1';

            GameState.setBattleCard(currentPlayerKey, selectedBattleCard);

            if ((GameState.mode === 'story' || GameState.type === 'pve') && currentPlayerKey === 'player1') {
                if (GameState.mode === 'story') {
                    // In story mode, opponent (NPC) automatically selects the first card
                    const npcPick = 0;
                    GameState.setBattleCard('player2', npcPick);
                    GameState.addLog(`[NPC] ç©å®¶2 è‡ªå‹•é¸æ“‡äº† ${GameState.player2.battleCard.name} ä½œç‚ºé¦–ç™¼ã€‚`, 'status');
                } else {
                    GameState.addLog(`[NPC] ${GameState.player2.name} æ´¾å‡ºäº† ${GameState.player2.battleCard.name} ä½œç‚ºé¦–ç™¼ã€‚`, 'status');
                }
                startBattle();
                return;
            }

            // In classic mode, check if both players have selected their cards
            const firstPlayerKey = GameState.firstPlayer === 1 ? 'player1' : 'player2';

            if (currentPlayerKey === firstPlayerKey) {
                // First player has chosen, now second player's turn
                selectionPhase = otherPlayerKey + '_draw';
                await startDrawPhase(otherPlayerKey);
            } else {
                // Second player has chosen, start battle
                startBattle();
            }
        };

        function startBattle() {
            document.getElementById('selectionPhase').classList.add('hidden');
            document.getElementById('battleContainer').style.display = 'flex';
            GameState.phase = 'battle';
            GameState.turnCount = 1;

            updateUI();
            GameState.addLog('æˆ°é¬¥é–‹å§‹ï¼', 'skill');
            updateBattleLog();

            // Trigger AI if it's Player 2's turn in story or pve
            if ((GameState.mode === 'story' || GameState.type === 'pve') && GameState.currentPlayer === 2) {
                setTimeout(playAITurn, 1200); // Wait a bit before AI acts
            }
        }

        function updateUI() {
            // Update turn indicator
            document.getElementById('turnCount').textContent = GameState.turnCount;

            // Update player names
            const p1NameElem = document.querySelector('#player1Area .player-name');
            const p2NameElem = document.querySelector('#player2Area .player-name');
            if (p1NameElem) p1NameElem.textContent = GameState.player1.name;
            if (p2NameElem) p2NameElem.textContent = GameState.player2.name;

            // Reset mobile view on UI update
            isShowingOpponent = false;
            const container = document.getElementById('battleContainer');
            const toggleBtn = document.getElementById('mobileToggleBtn');
            if (container) container.classList.remove('show-opponent-mobile');
            if (toggleBtn) toggleBtn.textContent = 'æŸ¥çœ‹å°æ‰‹';

            // Update player cards
            updatePlayerCard('player1', 'p1');
            updatePlayerCard('player2', 'p2');

            // Show/hide action buttons based on current player
            const isP1Turn = GameState.currentPlayer === 1;
            document.getElementById('p1Actions').style.display = isP1Turn ? 'flex' : 'none';

            if (GameState.mode === 'story' || GameState.type === 'pve') {
                document.getElementById('p2Actions').style.display = 'none';
            } else {
                document.getElementById('p2Actions').style.display = isP1Turn ? 'none' : 'flex';
            }

            document.getElementById('p1TurnBadge').classList.toggle('hidden', !isP1Turn);
            document.getElementById('p2TurnBadge').classList.toggle('hidden', isP1Turn);

            // Update Skill Button state
            document.getElementById('p1SkillBtn').disabled = !isP1Turn;
            document.getElementById('p2SkillBtn').disabled = isP1Turn;

            // Highlight active player
            document.getElementById('player1Area').classList.toggle('active-turn', isP1Turn);
            document.getElementById('player2Area').classList.toggle('active-turn', !isP1Turn);

            // Re-enable buttons for the active player (fix for buttons sticking disabled)
            if (isP1Turn) {
                const p1Btns = document.querySelectorAll('#p1Actions .action-btn');
                p1Btns.forEach(btn => btn.disabled = false);
            } else if (GameState.mode !== 'story' && GameState.type !== 'pve') {
                const p2Btns = document.querySelectorAll('#p2Actions .action-btn');
                p2Btns.forEach(btn => btn.disabled = false);
            }
        }

        function updatePlayerCard(playerKey, prefix) {
            const player = GameState[playerKey];
            const card = player.battleCard;

            if (!card) {
                document.getElementById(`${prefix}CharName`).textContent = 'ç„¡è§’è‰²';
                return;
            }

            document.getElementById(`${prefix}CharName`).textContent = card.name;
            document.getElementById(`${prefix}CharRarity`).textContent = getRarityName(card.rarity);
            document.getElementById(`${prefix}CharRarity`).className = `battle-char-rarity ${getRarityClass(card.rarity)}`;

            // HP bar
            const hpPercent = Math.max(0, Math.min(100, (card.hp / card.maxHp) * 100));
            document.getElementById(`${prefix}HpBar`).style.width = hpPercent + '%';
            document.getElementById(`${prefix}HpText`).textContent = `${Math.max(0, card.hp)} / ${card.maxHp}`;

            // Shield bar
            const shieldPercent = Math.min(100, (card.shield / card.maxHp) * 100);
            document.getElementById(`${prefix}ShieldBar`).style.width = shieldPercent + '%';
            document.getElementById(`${prefix}Shield`).textContent = card.shield;

            // ATK
            document.getElementById(`${prefix}Atk`).textContent = card.atk;

            // Status effects & Resources
            const statusDiv = document.getElementById(`${prefix}Status`);
            statusDiv.innerHTML = '';

            // 1. Status Effects
            card.statusEffects.forEach(effect => {
                const badge = document.createElement('span');
                badge.className = `status-badge ${effect.type}`;
                let text = effect.name || effect.type;

                if (effect.turns && effect.turns > 0 && !effect.permanent) {
                    text += ` (${effect.turns}å›)`;
                } else if (effect.permanent) {
                    text += ` (âˆ)`;
                }

                if (effect.hits !== undefined) {
                    text += ` [${effect.hits}æ¬¡]`;
                } else if (effect.value !== undefined && effect.type !== 'dot' && effect.type !== 'poison' && effect.type !== 'burn') {
                    text += `: ${effect.value}`;
                } else if (effect.chance !== undefined) {
                    text += ` ${effect.chance}%`;
                }

                badge.textContent = text;
                statusDiv.appendChild(badge);
            });

            // 2. Resources (Combo, stacks, etc.)
            if (card.resources) {
                Object.entries(card.resources).forEach(([key, value]) => {
                    const badge = document.createElement('span');
                    badge.className = 'status-badge resource';
                    badge.style.background = 'rgba(0, 255, 255, 0.2)';
                    badge.style.color = '#fff';
                    badge.textContent = `${key}: ${value}`;
                    statusDiv.appendChild(badge);
                });
            }

            // Passive
            const passiveDiv = document.getElementById(`${prefix}Passive`);
            if (card.passive) {
                passiveDiv.innerHTML = `
                <div style="font-size: 0.8rem; color: var(--neon-gold); margin: 5px 0; text-align: left; padding: 5px; background: rgba(255, 215, 0, 0.1); border-radius: 4px;">
                    <div style="font-weight: bold; margin-bottom: 2px;">è¢«å‹•: ${card.passive.name}</div>
                    <div style="color: #ddd; line-height: 1.2;">${card.passive.desc || 'ç„¡æè¿°'}</div>
                </div>`;
            } else {
                passiveDiv.innerHTML = '';
            }

            // Standby cards
            const standbyDiv = document.getElementById(`${prefix}Standby`);
            standbyDiv.innerHTML = '';
            player.standbyCards.forEach((c, idx) => {
                const div = document.createElement('div');
                div.className = `standby-card glass ${getRarityClass(c.rarity)}`;
                div.textContent = c.name;
                div.onclick = () => showCardDetails(c); // Click to view details
                standbyDiv.appendChild(div);
            });
        }

        function openSkillModal(playerKey) {
            const player = GameState[playerKey];
            const card = player.battleCard;
            if (!card) return;

            const modal = document.getElementById('skillPanelModal');
            const options = document.getElementById('skillModalOptions');
            const title = document.getElementById('skillModalTitle');

            title.textContent = `${player.name} - ä½¿ç”¨æŠ€èƒ½`;
            options.innerHTML = '';

            const isMyTurn = (playerKey === 'player1' && GameState.currentPlayer === 1) ||
                (playerKey === 'player2' && GameState.currentPlayer === 2);

            if (card.skills) {
                card.skills.forEach((skill, idx) => {
                    const btn = document.createElement('button');
                    btn.className = 'skill-btn-modal';
                    // Strict disable: Not my turn OR cooldown OR silence
                    const onCooldown = card.cooldowns[idx] > 0;
                    const isSilenced = card.statusEffects.some(e => e.type === 'silence');
                    btn.disabled = !isMyTurn || onCooldown || isSilenced;

                    btn.innerHTML = `
                        <div class="skill-name-modal">${skill.name}</div>
                        <div class="skill-desc-modal">${skill.desc || 'ç„¡æè¿°'}</div>
                        <div class="skill-footer-modal">
                            <span class="skill-cd-modal">${onCooldown ? `å†·å»ä¸­: ${card.cooldowns[idx]}` : `å†·å»: ${skill.cd}`}</span>
                            ${isSilenced ? '<span class="skill-silence-modal">è¢«æ²‰é»˜</span>' : ''}
                        </div>
                    `;

                    btn.onclick = async () => {
                        closeSkillModal();
                        await doAction('skill', idx);
                    };
                    options.appendChild(btn);
                });
            }
            modal.classList.add('active');
        }

        function closeSkillModal() {
            document.getElementById('skillPanelModal').classList.remove('active');
        }

        function updateBattleLog() {
            const logDiv = document.getElementById('battleLog');
            logDiv.innerHTML = '';
            GameState.battleLog.slice(0, 15).forEach(entry => {
                const div = document.createElement('div');
                div.className = `log-entry log-${entry.type}`;
                div.textContent = entry.message;
                logDiv.appendChild(div);
            });
        }

        async function doAction(type, skillIndex = null) {
            if (isProcessing) return;
            isProcessing = true;

            // Disable buttons visually
            document.querySelectorAll('.action-btn').forEach(btn => btn.disabled = true);

            try {
                const playerKey = GameState.currentPlayer === 1 ? 'player1' : 'player2';
                const opponentKey = GameState.currentPlayer === 1 ? 'player2' : 'player1';
                const attacker = GameState[playerKey].battleCard;
                const defender = GameState[opponentKey].battleCard;

                if (!attacker || !defender) return;

                if (type === 'attack') {
                    await BattleSystem.normalAttack(attacker, defender);
                } else if (type === 'skill') {
                    await BattleSystem.useSkill(attacker, defender, skillIndex); // Await async skill
                }

                updateUI();
                updateBattleLog();

                // Check for deaths
                const playersToCheck = ['player1', 'player2'];
                for (const p of playersToCheck) {
                    const card = GameState[p].battleCard;
                    if (card && card.hp <= 0) {
                        const died = GameState.handleDeath(p);
                        if (died) {
                            GameState.addLog(`${card.name} è¢«æ“Šæ•—ï¼`, 'damage');
                            updateUI();
                            updateBattleLog();

                            // If there are standby cards, must pick one
                            if (GameState[p].standbyCards.length > 0) {
                                await promptReplacement(p);
                            }
                        }
                    }
                }

                // Check win
                if (GameState.checkWin()) {
                    await Animations.victory(GameState.winner === 1 ? 'ç©å®¶1' : 'ç©å®¶2');
                    return;
                }

                // End turn
                GameState.endTurn();
                updateUI();
                updateBattleLog();

                // Trigger AI if it's Player 2's turn in story mode or PvE
                if ((GameState.mode === 'story' || GameState.type === 'pve') && GameState.currentPlayer === 2) {
                    setTimeout(playAITurn, 1200); // Wait a bit before AI acts
                }

            } finally {
                isProcessing = false;
                // Buttons will be re-enabled by updateUI based on turn state
                updateUI();
            }
        }

        // --- NPC AI Logic ---
        async function playAITurn() {
            if (GameState.winner !== null || GameState.currentPlayer !== 2) return;

            const card = GameState.player2.battleCard;
            if (!card) return; // Should not happen if replacement works

            // If stunned or sleeping, status effects are already processed by endTurn -> next turn start Of Turn.
            // Wait, startOfTurn might skip the turn immediately. We need to verify if it's still player 2's turn.
            if (GameState.currentPlayer !== 2) {
                // If it skipped to player 1
                return;
            }

            // Show thinking indicator
            const thinkingUI = document.getElementById('npcThinking');
            if (thinkingUI) thinkingUI.classList.remove('hidden');

            // Simulate thinking time (random between 1 to 2.5 seconds)
            const thinkTime = Math.floor(Math.random() * 1500) + 1000;

            setTimeout(async () => {
                const availableSkills = [];
                if (card.skills) {
                    // Check silence
                    const isSilenced = card.statusEffects.some(e => e.type === 'silence');
                    if (!isSilenced) {
                        card.skills.forEach((skill, idx) => {
                            if (card.cooldowns[idx] <= 0) {
                                availableSkills.push(idx);
                            }
                        });
                    }
                }

                const difficulty = localStorage.getItem('pveDifficulty') || 'normal';

                let actionType = 'attack';
                let skillIdx = null;

                // Smart AI Decisions based on difficulty
                if (difficulty === 'hard') {
                    // Try to retreat if low HP and have healthy standby
                    const hpPercent = card.hp / card.maxHp;
                    if (hpPercent < 0.3 && GameState.player2.standbyCards.length > 0) {
                        const healthyStandbys = GameState.player2.standbyCards.filter(c => c.hp / c.maxHp > 0.6);
                        if (healthyStandbys.length > 0 && Math.random() < 0.8) { // 80% retreat chance when low HP
                            // Find the one with highest HP
                            let bestIdx = 0;
                            let maxHp = 0;
                            GameState.player2.standbyCards.forEach((c, i) => {
                                if (c.hp > maxHp) { maxHp = c.hp; bestIdx = i; }
                            });
                            actionType = 'retreat';
                            skillIdx = bestIdx;
                        }
                    }

                    if (actionType !== 'retreat') {
                        if (availableSkills.length > 0) {
                            // Hard mode prioritizes skills whenever possible
                            actionType = 'skill';
                            // Prioritize healing/shield if low HP (e.g., skill name contains keywords)
                            if (hpPercent < 0.5) {
                                const defensiveSkills = availableSkills.filter(idx =>
                                    card.skills[idx].desc.includes('ä¿è­·') ||
                                    card.skills[idx].desc.includes('æ¢å¾©') ||
                                    card.skills[idx].desc.includes('è­·ç›¾') ||
                                    card.skills[idx].desc.includes('ç„¡æ•µ')
                                );
                                if (defensiveSkills.length > 0) {
                                    skillIdx = defensiveSkills[Math.floor(Math.random() * defensiveSkills.length)];
                                } else {
                                    skillIdx = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                                }
                            } else {
                                skillIdx = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                            }
                        } else {
                            actionType = 'attack';
                        }
                    }
                } else if (difficulty === 'easy') {
                    // Easy mode: Never retreats. 50% chance to forget to use skills.
                    if (availableSkills.length > 0 && Math.random() < 0.5) {
                        actionType = 'skill';
                        skillIdx = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                    } else {
                        actionType = 'attack';
                    }
                }

                if (thinkingUI) thinkingUI.classList.add('hidden');

                if (actionType === 'retreat') {
                    GameState.addLog(`[NPC] èªç‚ºæƒ…å‹¢ä¸åˆ©ï¼Œé¸æ“‡æ’¤æ›è§’è‰²ç‚º ${GameState.player2.standbyCards[skillIdx].name}`, 'status');
                } else {
                    GameState.addLog(`[NPC] æ±ºå®šä½¿ç”¨ ${actionType === 'skill' ? card.skills[skillIdx].name : 'æ™®æ”»'}`, 'status');
                }
                updateBattleLog();

                setTimeout(async () => {
                    if (actionType === 'retreat') {
                        BattleSystem.retreat('player2', skillIdx);
                        updateUI();
                        GameState.endTurn();
                        updateUI();
                    } else {
                        await doAction(actionType, skillIdx);
                    }
                }, 400); // Short delay before executing to make log visible
            }, thinkTime);
        }
        // --------------------

        function promptReplacement(playerKey) {
            return new Promise((resolve) => {
                const player = GameState[playerKey];

                // --- Story / PvE mode AI check for replacements ---
                if ((GameState.mode === 'story' || GameState.type === 'pve') && playerKey === 'player2') {
                    const difficulty = localStorage.getItem('pveDifficulty') || 'normal';

                    if (player.standbyCards.length > 0) {
                        setTimeout(() => {
                            let pickIdx = 0;

                            // Hard mode picks the best character (highest combined HP+ATK)
                            if (difficulty === 'hard') {
                                let maxScore = 0;
                                player.standbyCards.forEach((c, idx) => {
                                    const baseAtk = typeof c.atk === 'object' ? Math.floor((c.atk.min + c.atk.max) / 2) : c.atk;
                                    const score = c.hp + (baseAtk * 10);
                                    if (score > maxScore) {
                                        maxScore = score;
                                        pickIdx = idx;
                                    }
                                });
                            }

                            player.battleCard = player.standbyCards.splice(pickIdx, 1)[0];
                            GameState.addLog(`[NPC] ${player.name} è‡ªå‹•æ›¿æ› ${player.battleCard.name} ä¸Šå ´ï¼`, 'status');
                            updateUI();
                            updateBattleLog();
                            resolve();
                        }, 1000); // Small delay for visual pacing
                        return;
                    }
                }
                // --------------------------------------------

                const modal = document.getElementById('replacementModal');
                const optionsDiv = document.getElementById('replacementOptions');
                const title = document.getElementById('replacementTitle');

                title.textContent = `${player.name} çš„è§’è‰²å·²é™£äº¡ï¼è«‹é¸æ“‡æ›¿æ›è§’è‰²`;
                optionsDiv.innerHTML = '';
                modal.classList.add('active');

                player.standbyCards.forEach((card, idx) => {
                    const div = document.createElement('div');
                    div.className = `select-card glass ${getRarityClass(card.rarity)}`;
                    div.innerHTML = renderCardInfo(card);

                    div.onclick = () => {
                        // Perform the swap (remove from standby, set as battle)
                        player.battleCard = player.standbyCards.splice(idx, 1)[0];
                        GameState.addLog(`${player.name} æ´¾é£ ${player.battleCard.name} ä¸Šå ´ï¼`, 'status');

                        modal.classList.remove('active');
                        updateUI();
                        updateBattleLog();
                        resolve();
                    };
                    optionsDiv.appendChild(div);
                });
            });
        }

        function showRetreat() {
            if (isProcessing) return;
            const playerKey = GameState.currentPlayer === 1 ? 'player1' : 'player2';
            const player = GameState[playerKey];

            if (player.standbyCards.length === 0) {
                GameState.addLog('å‚™æˆ°å€æ²’æœ‰è§’è‰²å¯æ›¿æ›ï¼', 'status');
                updateBattleLog();
                return;
            }

            const optionsDiv = document.getElementById('retreatOptions');
            optionsDiv.innerHTML = '';

            player.standbyCards.forEach((card, idx) => {
                const div = document.createElement('div');
                div.className = `select-card glass ${getRarityClass(card.rarity)}`;
                div.innerHTML = renderCardInfo(card);

                div.onclick = () => {
                    BattleSystem.retreat(playerKey, idx);
                    closeRetreatModal();
                    updateUI();
                    updateBattleLog();
                    GameState.endTurn();
                    updateUI();
                };
                optionsDiv.appendChild(div);
            });

            document.getElementById('retreatModal').classList.add('active');
        }

        function closeRetreatModal() {
            document.getElementById('retreatModal').classList.remove('active');
        }

        function showCardDetails(card) {
            const modal = document.getElementById('cardDetailsModal');
            const content = document.getElementById('cardDetailsContent');

            let skillsHtml = '';
            if (card.skills && card.skills.length > 0) {
                skillsHtml = '<div style="margin-top: 15px; text-align: left;">';
                card.skills.forEach(skill => {
                    skillsHtml += `
                        <div style="margin-top: 10px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                            <div style="color: var(--neon-cyan); font-weight: bold;">${skill.name} <span style="font-size: 0.8rem; color: #888;">(CD: ${skill.cd})</span></div>
                            <div style="font-size: 0.9rem; color: #ddd; margin-top: 3px;">${skill.desc || 'ç„¡æè¿°'}</div>
                        </div>`;
                });
                skillsHtml += '</div>';
            }

            content.innerHTML = `
                <div class="battle-card-header" style="justify-content: center; margin-bottom: 20px;">
                    <span class="battle-char-name" style="font-size: 2rem;">${card.name}</span>
                </div>
                <div style="display: flex; justify-content: center; gap: 20px; font-size: 1.2rem; margin-bottom: 20px;">
                    <span style="color: #ff6b6b;">HP: ${card.hp}/${card.maxHp}</span>
                    <span style="color: #ffd93d;">ATK: ${typeof card.atk === 'object' ? `${card.atk.min}-${card.atk.max}` : card.atk}</span>
                </div>
                ${card.passive ? `
                    <div style="margin-bottom: 15px; text-align: left; background: rgba(255, 215, 0, 0.1); padding: 10px; border-left: 3px solid var(--neon-gold); border-radius: 4px;">
                        <div style="color: var(--neon-gold); font-weight: bold;">è¢«å‹•: ${card.passive.name}</div>
                        <div style="font-size: 0.9rem; margin-top: 5px;">${card.passive.desc || 'ç„¡æè¿°'}</div>
                    </div>` : ''}
                ${skillsHtml}
                <button class="btn" style="margin-top: 20px; width: 100%;" onclick="document.getElementById('cardDetailsModal').classList.remove('active')">é—œé–‰</button>
            `;

            modal.classList.add('active');
        }

        // Close modal on outside click
        document.getElementById('cardDetailsModal').onclick = (e) => {
            if (e.target.id === 'cardDetailsModal') {
                e.target.classList.remove('active');
            }
        };

        function finishStoryBattle() {
            if (GameState.winner === 1) {
                unlockNextNode(GameState.currentChapterId, GameState.currentNodeIndex);

                const chapter = STORY_CHAPTERS.find(c => c.id === GameState.currentChapterId);
                const nextIndex = GameState.currentNodeIndex + 1;

                if (nextIndex < chapter.nodes.length) {
                    localStorage.setItem('story_current_node', nextIndex);
                    const nextNode = chapter.nodes[nextIndex];
                    if (nextNode.type === 'dialogue') {
                        location.href = 'story_runner.html';
                    } else if (nextNode.type === 'battle') {
                        location.reload();
                    }
                } else {
                    alert('ç« ç¯€å®Œæˆï¼');
                    location.href = 'story_menu.html';
                }
            } else {
                if (confirm('æˆ°é¬¥å¤±æ•—ï¼è¦é‡æ–°æŒ‘æˆ°å—ï¼Ÿ')) {
                    location.reload();
                } else {
                    location.href = 'story_menu.html';
                }
            }
        }

        let isProcessing = false;

        // Initialize game
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>

</html>