<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>éœ“è™¹ç‰Œ - å°æˆ°</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="css/styles.css">
    <script src="js/theme.js"></script>
</head>

<body>
    <!-- Theme Toggle Removed -->

    <!-- Animation Overlay -->
    <div class="animation-overlay hidden" id="animationOverlay"></div>

    <!-- Network Waiting Overlay -->
    <div class="modal-overlay hidden" id="networkWaitingOverlay"
        style="z-index: 1000; background: rgba(0, 0, 0, 0.85);">
        <div class="modal glass" style="text-align: center;">
            <h2 id="networkWaitingTitle" class="neon-text" style="color: var(--neon-cyan);">é€£ç·šå¤§å»³</h2>
            <p id="networkWaitingText" style="margin: 20px 0; font-size: 1.2rem; color: var(--text-secondary);">
                åˆå§‹åŒ–ç¶²è·¯ä¸­...</p>
            <div id="networkRoomCode"
                style="font-size: 3rem; font-weight: bold; letter-spacing: 5px; color: var(--neon-gold); margin: 20px 0; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);"
                class="hidden"></div>
            <button class="btn" onclick="location.href='index.html'"
                style="margin-top: 20px; opacity: 0.8;">å–æ¶ˆé€£ç·š</button>
        </div>
    </div>

    <!-- Card Selection Phase -->
    <div class="selection-phase hidden" id="selectionPhase">
        <h2 class="selection-title" id="selectionTitle">ç©å®¶1 æŠ½ç‰Œéšæ®µ</h2>
        <p class="selection-subtitle" id="selectionSubtitle">é¸æ“‡ä¸€å¼µç‰Œæ”¾å…¥æˆ°é¬¥å€</p>
        <div class="drawn-cards" id="drawnCards"></div>
        <div class="selection-info" id="selectionInfo"></div>
        <button class="btn confirm-selection" id="confirmSelection" disabled>ç¢ºèªé¸æ“‡</button>
    </div>

    <!-- Battle Screen -->
    <div class="battle-container" id="battleContainer">
        <!-- Player 1 Area (Left / Top) -->
        <div class="player-area player1" id="player1Area">
            <div class="player-header glass">
                <span class="player-name">ç©å®¶1</span>
                <span class="thinking-indicator hidden" id="p1Thinking"
                    style="margin-left: 10px; color: var(--neon-cyan); font-size: 0.9rem;">
                    æ€è€ƒä¸­<span class="thinking-dots"><span>.</span><span>.</span><span>.</span></span>
                </span>
                <span class="turn-badge hidden" id="p1TurnBadge">ä½ çš„å›åˆ</span>
            </div>

            <div class="battle-card glass" id="p1BattleCard">
                <div class="battle-card-header">
                    <span class="battle-char-name" id="p1CharName">-</span>
                    <span class="battle-char-rarity" id="p1CharRarity">-</span>
                </div>

                <div class="hp-bar-container">
                    <div class="bar-wrapper">
                        <div class="shield-bar" id="p1ShieldBar" style="width: 0%"></div>
                        <div class="hp-bar" id="p1HpBar" style="width: 100%"></div>
                        <div class="bar-text" id="p1HpText">100 / 100</div>
                    </div>
                </div>

                <div class="stats-row">
                    <span class="stat stat-atk">âš” ATK: <span id="p1Atk">0</span></span>
                    <span class="stat">ğŸ›¡ è­·ç›¾: <span id="p1Shield">0</span></span>
                </div>

                <div class="status-effects" id="p1Status"></div>
                <div class="passive-info" id="p1Passive"></div>


                <div class="action-buttons" id="p1Actions">
                    <button class="btn action-btn attack-btn" onclick="doAction('attack')">æ™®æ”»</button>
                    <button class="btn action-btn skill-btn-main" id="p1SkillBtn"
                        onclick="openSkillModal('player1')">ä½¿ç”¨æŠ€èƒ½</button>
                    <button class="btn action-btn view-skill-btn hidden" id="p1ViewSkillBtn"
                        onclick="openViewSkillModal('player1')">æŸ¥çœ‹å°æ‰‹æŠ€èƒ½</button>
                    <button class="btn action-btn retreat-btn" onclick="showRetreat()">æ’¤é€€</button>
                </div>
            </div>

            <div class="standby-area glass">
                <div class="standby-title">å‚™æˆ°å€</div>
                <div class="standby-cards" id="p1Standby"></div>
            </div>
        </div>

        <!-- Center Battle Info -->
        <div class="battle-center glass">
            <div class="turn-indicator" id="turnIndicator">
                å›åˆ <span id="turnCount">0</span>
            </div>

            <button class="btn btn-gold emoji-btn hidden" id="p1EmojiBtn" onclick="openEmojiMenu()"
                style="margin-left: 10px; padding: 5px 10px; font-size: 0.9rem;">ğŸ’¬ è¡¨æƒ…</button>

            <button class="btn btn-magenta mobile-toggle-btn" id="mobileToggleBtn"
                onclick="toggleMobileView()">æŸ¥çœ‹å°æ‰‹</button>
            <div class="battle-log" id="battleLog"></div>
        </div>

        <!-- Player 2 Area (Right / Bottom) -->
        <div class="player-area player2" id="player2Area">
            <div class="player-header glass">
                <span class="player-name">ç©å®¶2</span>
                <span class="thinking-indicator hidden" id="p2Thinking"
                    style="margin-left: 10px; color: var(--neon-cyan); font-size: 0.9rem;">
                    æ€è€ƒä¸­<span class="thinking-dots"><span>.</span><span>.</span><span>.</span></span>
                </span>
                <span class="turn-badge hidden" id="p2TurnBadge">ä½ çš„å›åˆ</span>
            </div>

            <div class="battle-card glass" id="p2BattleCard">
                <div class="battle-card-header">
                    <span class="battle-char-name" id="p2CharName">-</span>
                    <span class="battle-char-rarity" id="p2CharRarity">-</span>
                </div>

                <div class="hp-bar-container">
                    <div class="bar-wrapper">
                        <div class="shield-bar" id="p2ShieldBar" style="width: 0%"></div>
                        <div class="hp-bar" id="p2HpBar" style="width: 100%"></div>
                        <div class="bar-text" id="p2HpText">100 / 100</div>
                    </div>
                </div>

                <div class="stats-row">
                    <span class="stat stat-atk">âš” ATK: <span id="p2Atk">0</span></span>
                    <span class="stat">ğŸ›¡ è­·ç›¾: <span id="p2Shield">0</span></span>
                </div>

                <div class="status-effects" id="p2Status"></div>
                <div class="passive-info" id="p2Passive"></div>


                <div class="action-buttons" id="p2Actions">
                    <button class="btn action-btn attack-btn" onclick="doAction('attack')">æ™®æ”»</button>
                    <button class="btn action-btn skill-btn-main" id="p2SkillBtn"
                        onclick="openSkillModal('player2')">ä½¿ç”¨æŠ€èƒ½</button>
                    <button class="btn action-btn view-skill-btn hidden" id="p2ViewSkillBtn"
                        onclick="openViewSkillModal('player2')">æŸ¥çœ‹å°æ‰‹æŠ€èƒ½</button>
                    <button class="btn action-btn retreat-btn" onclick="showRetreat()">æ’¤é€€</button>
                </div>
            </div>

            <div class="standby-area glass">
                <div class="standby-title">å‚™æˆ°å€</div>
                <div class="standby-cards" id="p2Standby"></div>
            </div>
        </div>
    </div>

    <!-- Replacement Modal (Mandatory death replacement) -->
    <div class="modal-overlay" id="replacementModal">
        <div class="modal glass" style="max-width: 800px;">
            <h2 id="replacementTitle">è§’è‰²å·²é™£äº¡ï¼é¸æ“‡æ›¿æ›ä¸Šå ´çš„è§’è‰²</h2>
            <div id="replacementOptions" class="drawn-cards"></div>
        </div>
    </div>

    <!-- Retreat Modal -->
    <div class="modal-overlay" id="retreatModal">
        <div class="modal glass" style="max-width: 800px;">
            <h2>æ’¤é€€è§’è‰²</h2>
            <p style="margin-bottom: 20px; color: var(--text-secondary);">é¸æ“‡ä¸€å€‹éšŠå‹ä¾†æ›¿æ›ç•¶å‰ä¸Šå ´çš„è§’è‰²</p>
            <div id="retreatOptions" class="drawn-cards"></div>
            <button class="btn" onclick="closeRetreatModal()" style="margin-top: 20px;">å–æ¶ˆ</button>
        </div>
    </div>

    <!-- Skill Panel Modal -->
    <div class="modal-overlay" id="skillPanelModal">
        <div class="modal glass" style="max-width: 800px;">
            <h2 id="skillModalTitle">ä½¿ç”¨æŠ€èƒ½</h2>
            <div id="skillModalOptions" class="skills-container-modal"></div>
            <button class="btn" onclick="closeSkillModal()" style="margin-top: 20px; width: 100%;">è¿”å›</button>
        </div>
    </div>

    <!-- View Skill Panel Modal -->
    <div class="modal-overlay" id="viewSkillPanelModal">
        <div class="modal glass" style="max-width: 800px;">
            <h2 id="viewSkillModalTitle">æŸ¥çœ‹æŠ€èƒ½</h2>
            <div id="viewSkillModalOptions" class="skills-container-modal"></div>
            <button class="btn" onclick="closeViewSkillModal()" style="margin-top: 20px; width: 100%;">é—œé–‰</button>
        </div>
    </div>

    <!-- Card Details Modal -->

    <!-- Card Details Modal -->
    <div class="modal-overlay" id="cardDetailsModal">
        <div class="modal glass" id="cardDetailsContent">
            <!-- Content injected via JS -->
        </div>
    </div>
    <!-- Story Battle End Modals -->
    <div class="modal-overlay" id="storyCompleteModal">
        <div class="modal">
            <h2 class="neon-text" style="text-shadow: 0 0 15px rgba(255, 0, 85, 0.4); color: var(--neon-pink);">ç« ç¯€å®Œæˆ
            </h2>
            <p style="color: var(--text-secondary); margin-bottom: 25px; font-size: 1.1rem;">é˜²ç·šå·²çªç ´ï¼Œæ–°çš„åŠ‡æƒ…å·²è§£é–ï¼</p>
            <div class="modal-buttons" style="display: flex; justify-content: center;">
                <button class="btn btn-magenta" onclick="location.href='story_menu.html'"
                    style="font-size: 1.2rem; padding: 15px 30px;">è¿”å›æ•…äº‹å¤§å»³</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="storyFailModal">
        <div class="modal">
            <h2 class="neon-text" style="text-shadow: 0 0 15px rgba(255, 0, 0, 0.4); color: #ff4444;">æˆ°é¬¥å¤±æ•—</h2>
            <p style="color: var(--text-secondary); margin-bottom: 25px; font-size: 1.1rem;">åæŠ—è»è¢«æ“Šæ½°ï¼Œæ˜¯å¦è¦é‡æ–°æŒ‘æˆ°ï¼Ÿ</p>
            <div class="modal-buttons" style="display: flex; justify-content: center; gap: 15px;">
                <button class="btn btn-magenta" onclick="location.reload()"
                    style="font-size: 1.1rem; padding: 10px 20px;">å†æ¬¡æŒ‘æˆ°</button>
                <button class="btn" onclick="location.href='story_menu.html'"
                    style="font-size: 1.1rem; padding: 10px 20px;">æ’¤é€€</button>
            </div>
        </div>
    </div>

    <!-- Emoji Picker Modal -->
    <div class="modal-overlay" id="emojiModal" onclick="this.classList.remove('active')">
        <div class="modal glass" style="max-width: 400px; padding: 20px;" onclick="event.stopPropagation()">
            <h3 style="margin-bottom: 15px; text-align: center; color: var(--neon-cyan);">ç™¼é€è¡¨æƒ…</h3>
            <div
                style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; font-size: 2.5rem; text-align: center;">
                <div style="cursor: pointer; transition: transform 0.2s;" onclick="sendEmoji('ğŸ˜€')"
                    onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'">ğŸ˜€
                </div>
                <div style="cursor: pointer; transition: transform 0.2s;" onclick="sendEmoji('ğŸ¤¡')"
                    onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'">ğŸ¤¡
                </div>
                <div style="cursor: pointer; transition: transform 0.2s;" onclick="sendEmoji('ğŸ¥µ')"
                    onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'">ğŸ¥µ
                </div>
                <div style="cursor: pointer; transition: transform 0.2s;" onclick="sendEmoji('ğŸ¤')"
                    onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'">ğŸ¤
                </div>
                <div style="cursor: pointer; transition: transform 0.2s;" onclick="sendEmoji('ğŸ˜')"
                    onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'">ğŸ˜
                </div>
                <div style="cursor: pointer; transition: transform 0.2s;" onclick="sendEmoji('ğŸ¤”')"
                    onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'">ğŸ¤”
                </div>
                <div style="cursor: pointer; transition: transform 0.2s;" onclick="sendEmoji('ğŸ‘')"
                    onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'">ğŸ‘
                </div>
                <div style="cursor: pointer; transition: transform 0.2s;" onclick="sendEmoji('ğŸ”¥')"
                    onmouseover="this.style.transform='scale(1.2)'" onmouseout="this.style.transform='scale(1)'">ğŸ”¥
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="js/core/rng.js"></script>
    <script src="js/core/networkManager.js"></script>
    <script src="js/data/story.js"></script>
    <script src="js/data/characters_part1.js"></script>
    <script src="js/data/characters_part2.js"></script>
    <script src="js/data/characters_part3.js"></script>
    <script src="js/data/characters_part4.js"></script>
    <script src="js/data/characters_part5.js"></script>
    <script src="js/data/characters_part6.js"></script>
    <script src="js/data/characters.js"></script>
    <script src="js/core/gameState.js"></script>
    <script src="js/core/battleSystem.js"></script>
    <script src="js/ui/animations.js"></script>
    <script>
        // Game initialization
        let selectionPhase = 'p1_draw';
        let selectedBattleCard = null;
        let isShowingOpponent = false;

        function toggleMobileView() {
            const container = document.getElementById('battleContainer');
            const btn = document.getElementById('mobileToggleBtn');
            isShowingOpponent = !isShowingOpponent;

            if (isShowingOpponent) {
                container.classList.add('show-opponent-mobile');
                btn.textContent = 'è¿”å›æˆ‘çš„ç•«é¢';
            } else {
                container.classList.remove('show-opponent-mobile');
                btn.textContent = 'æŸ¥çœ‹å°æ‰‹';
            }
        }

        function renderCardInfo(card) {
            let skillsHtml = '';
            if (card.skills && card.skills.length > 0) {
                skillsHtml = '<div style="margin-top: 10px; flex-grow: 1; overflow-y: auto; text-align: left;">';
                card.skills.forEach(skill => {
                    skillsHtml += `<div class="skill-preview" style="margin-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px;">
                        <div style="color: var(--neon-cyan); font-weight: bold;">â€¢ ${skill.name} <span style="font-size: 0.7rem; color: #888;">(CD:${skill.cd})</span></div>
                        <div style="font-size: 0.8rem; color: #ddd; margin-top: 2px; line-height: 1.3;">${skill.desc || 'ç„¡æè¿°'}</div>
                    </div>`;
                });
                skillsHtml += '</div>';
            }

            return `
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span style="font-size: 0.8rem; color: var(--text-secondary);">#${card.id}</span>
                    <span class="${getRarityClass(card.rarity)}" style="font-size: 0.75rem;">${getRarityName(card.rarity)}</span>
                </div>
                <div style="font-size: 1.3rem; font-weight: bold; margin-bottom: 5px; color: var(--text-primary); text-shadow: 0 0 5px currentColor;">${card.name}</div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px; font-size: 0.9rem; background: rgba(0,0,0,0.3); padding: 5px; border-radius: 4px;">
                    <span style="color: #ff6b6b;">HP: ${card.hp}/${card.maxHp}</span>
                    <span style="color: #ffd93d;">ATK: ${typeof card.atk === 'object' ? `${card.atk.min}-${card.atk.max}` : card.atk}</span>
                </div>
                ${card.passive ? `
                    <div style="font-size: 0.8rem; color: var(--neon-gold); margin-bottom: 8px; text-align: left; background: rgba(255, 215, 0, 0.1); padding: 5px; border-radius: 4px;">
                        <div style="font-weight: bold;">è¢«å‹•: ${card.passive.name}</div>
                        <div style="margin-top: 2px; line-height: 1.2;">${card.passive.desc || 'ç„¡æè¿°'}</div>
                    </div>` : ''}
                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px; border-bottom: 1px solid var(--text-secondary);">æŠ€èƒ½:</div>
                ${skillsHtml}
            `;
        }

        async function initGame() {
            const mode = localStorage.getItem('gameMode') || 'classic';
            const type = localStorage.getItem('gameType') || 'pvp';
            const difficulty = localStorage.getItem('pveDifficulty') || 'normal';

            // Show emoji button for online mode
            if (mode === 'online') {
                document.getElementById('p1EmojiBtn').classList.remove('hidden');

                // Expose emoji function to global Animations object
                window.Animations = window.Animations || {};
                window.Animations.showEmoji = function (emoji, playerKey) {
                    showEmojiAnimation(emoji, playerKey);
                };
            }

            if (mode === 'story') {
                const chapterId = localStorage.getItem('story_current_chapter');
                const nodeIndex = parseInt(localStorage.getItem('story_current_node'), 10);
                GameState.initStoryMode(chapterId, nodeIndex);

                document.getElementById('selectionPhase').classList.remove('hidden');
                document.getElementById('battleContainer').style.display = 'none';

                selectionPhase = 'p1_draw';
                document.getElementById('selectionTitle').textContent = `${GameState.player1.name} é¸æ“‡é¦–ç™¼è§’è‰²`;
                renderSelectionCards('player1', GameState.player1.allCards);
            } else if (mode === 'online') {
                window.localOnlineRole = localStorage.getItem('onlineRole');
                const role = window.localOnlineRole;
                const overlay = document.getElementById('networkWaitingOverlay');
                overlay.classList.remove('hidden');
                overlay.classList.add('active');

                NetManager.onConnected = async () => {
                    overlay.classList.remove('active');
                    overlay.classList.add('hidden');
                    GameState.init('online', 'pvp', 'normal');

                    if (role === 'host') {
                        // Host defines first player using RNG
                        const firstPlayer = window.GameRNG.nextBoolean() ? 1 : 2;
                        NetManager.sendState({ type: 'first_player', firstPlayer });
                        GameState.firstPlayer = firstPlayer;
                        GameState.currentPlayer = firstPlayer;

                        // Play synced coin flip
                        await Animations.coinFlip(firstPlayer);

                        // BOTH players draw deterministically from seed
                        GameState.drawCards('player1', GameState.getCardCount());
                        GameState.drawCards('player2', GameState.getCardCount());

                        // ALL players pick simultaneously
                        const localPlayerKey = 'player1';
                        selectionPhase = localPlayerKey + '_draw';
                        await startDrawPhase(localPlayerKey, false); // false = don't redraw
                    }
                };

                NetManager.onDataReceived = (action) => {
                    handleRemoteAction(action);
                };

                NetManager.onPeerStateChange = async (state) => {
                    if (state.type === 'first_player' && role === 'join') {
                        // CRITICAL FIX: Joiner must also consume 1 random number from GameRNG 
                        // so that its RNG state perfectly matches the Host's state for the upcoming card draws!
                        window.GameRNG.nextBoolean();

                        GameState.firstPlayer = state.firstPlayer;
                        GameState.currentPlayer = state.firstPlayer;

                        // Play synced coin flip
                        await Animations.coinFlip(state.firstPlayer);

                        // BOTH players draw deterministically from seed
                        GameState.drawCards('player1', GameState.getCardCount());
                        GameState.drawCards('player2', GameState.getCardCount());

                        const localPlayerKey = 'player2';
                        selectionPhase = localPlayerKey + '_draw';
                        await startDrawPhase(localPlayerKey, false); // false = don't redraw
                    } else if (state.type === 'thinking') {
                        // Show opponent thinking
                        const opponentThinkingId = role === 'host' ? 'p2Thinking' : 'p1Thinking';
                        const thinkingUI = document.getElementById(opponentThinkingId);
                        if (thinkingUI) {
                            if (state.isThinking) {
                                thinkingUI.classList.remove('hidden');
                                thinkingUI.innerHTML = 'æ€è€ƒä¸­<span class="thinking-dots"><span>.</span><span>.</span><span>.</span></span>';
                            } else {
                                thinkingUI.classList.add('hidden');
                            }
                        }
                    }
                };

                NetManager.onDisconnected = () => {
                    alert('é€£ç·šå·²ä¸­æ–·ã€‚å°æ–¹å·²é›¢é–‹ã€‚');
                    location.href = 'index.html';
                };

                if (role === 'host') {
                    // Host Player is Player 1
                    document.getElementById('networkWaitingTitle').textContent = 'é€£ç·šå¤§å»³';
                    document.getElementById('networkWaitingText').textContent = 'è«‹å°‡æ­¤ä»£ç¢¼äº¤çµ¦æœ‹å‹ï¼Œç­‰å¾…åŠ å…¥...';
                    const codeLabel = document.getElementById('networkRoomCode');
                    codeLabel.classList.remove('hidden');
                    codeLabel.textContent = 'ç”Ÿæˆä¸­...';

                    // Force show overlay just in case
                    document.getElementById('networkWaitingOverlay').classList.remove('hidden');
                    document.getElementById('networkWaitingOverlay').classList.add('active');

                    try {
                        const roomId = await NetManager.initHost();
                        codeLabel.textContent = roomId;
                    } catch (err) {
                        alert('ç„¡æ³•å»ºç«‹é€£ç·š: ' + err);
                        location.href = 'index.html';
                    }
                } else if (role === 'join') {
                    // Joined Player is Player 2
                    const roomId = localStorage.getItem('roomId');
                    document.getElementById('networkWaitingTitle').textContent = 'é€£ç·šå¤§å»³';
                    document.getElementById('networkWaitingText').textContent = `å˜—è©¦åŠ å…¥æˆ¿é–“ [${roomId}]...`;

                    // Force show overlay just in case
                    document.getElementById('networkWaitingOverlay').classList.remove('hidden');
                    document.getElementById('networkWaitingOverlay').classList.add('active');

                    try {
                        await NetManager.joinRoom(roomId);
                    } catch (err) {
                        alert('ç„¡æ³•é€£ç·šè‡³æˆ¿é–“: ' + err);
                        location.href = 'index.html';
                    }
                }

            } else {
                GameState.init(mode, type, difficulty);

                // Coin flip
                const firstPlayer = await Animations.coinFlip();
                GameState.firstPlayer = firstPlayer;
                GameState.currentPlayer = firstPlayer;

                if (type === 'pve') {
                    // Draw cards silently for NPC
                    const npcCards = GameState.drawCards('player2', GameState.getCardCount());
                    if (difficulty === 'hell') {
                        GameState.player2.name = 'NPC (åœ°ç„)';
                    } else if (difficulty === 'hard') {
                        GameState.player2.name = 'NPC (å›°é›£)';
                    } else if (difficulty === 'easy') {
                        GameState.player2.name = 'NPC (ç°¡å–®)';
                    } else {
                        GameState.player2.name = 'NPC';
                    }

                    // NPC selects a random card
                    GameState.setBattleCard('player2', Math.floor(Math.random() * GameState.getCardCount()));

                    // Player 1 draw, regardless of firstPlayer
                    selectionPhase = 'player1_draw';
                    await startDrawPhase('player1');
                } else {
                    // Draw phase for the first player
                    const firstPlayerKey = firstPlayer === 1 ? 'player1' : 'player2';
                    selectionPhase = firstPlayerKey + '_draw';
                    await startDrawPhase(firstPlayerKey);
                }
            }
        }

        async function startDrawPhase(playerKey, doDraw = true) {
            const cardCount = GameState.getCardCount();
            let cards;

            if (doDraw) {
                cards = GameState.drawCards(playerKey, cardCount);
            } else {
                cards = GameState[playerKey].allCards;
            }

            document.getElementById('selectionPhase').classList.remove('hidden');
            document.getElementById('battleContainer').style.display = 'none';

            document.getElementById('selectionTitle').textContent =
                playerKey === 'player1' ? 'ç©å®¶1 æŠ½ç‰Œéšæ®µ' : 'ç©å®¶2 æŠ½ç‰Œéšæ®µ';

            // Show card draw animation
            await Animations.drawCards(cards);

            // Show selection UI
            renderSelectionCards(playerKey, cards);
        }

        function renderSelectionCards(playerKey, cards) {
            const container = document.getElementById('drawnCards');
            container.innerHTML = '';

            cards.forEach((card, idx) => {
                const div = document.createElement('div');
                div.className = `select-card glass ${getRarityClass(card.rarity)}`;
                div.innerHTML = renderCardInfo(card);
                div.onclick = () => selectCard(playerKey, idx);
                container.appendChild(div);
            });

            selectedBattleCard = null;
            updateSelectionInfo();
        }

        function selectCard(playerKey, idx) {
            const cards = document.querySelectorAll('.select-card');
            cards.forEach((c, i) => {
                c.classList.remove('selected-battle');
                if (i === idx) c.classList.add('selected-battle');
            });

            selectedBattleCard = idx;
            updateSelectionInfo();
        }

        function updateSelectionInfo() {
            const btn = document.getElementById('confirmSelection');
            btn.disabled = selectedBattleCard === null;

            document.getElementById('selectionInfo').textContent =
                selectedBattleCard !== null ? 'å·²é¸æ“‡æˆ°é¬¥è§’è‰²' : 'è«‹é¸æ“‡ä¸€å¼µç‰Œä½œç‚ºæˆ°é¬¥è§’è‰²';
        }

        function renderWaitingForOpponentSelection() {
            document.getElementById('selectionPhase').classList.add('hidden');
            const overlay = document.getElementById('networkWaitingOverlay');
            document.getElementById('networkWaitingTitle').textContent = 'ç­‰å¾…å°æ‰‹...';
            document.getElementById('networkWaitingText').textContent = 'å°æ‰‹æ­£åœ¨é¸æ“‡å‡ºæˆ°è§’è‰²';
            document.getElementById('networkRoomCode').classList.add('hidden');
            overlay.classList.add('active');
        }

        function handleRemoteAction(action) {
            const opponentKey = NetManager.isHost ? 'player2' : 'player1';
            const localKey = NetManager.isHost ? 'player1' : 'player2';

            if (action.type === 'select_initial') {
                GameState.setBattleCard(opponentKey, action.cardIdx);

                // Both players selected
                if (GameState.player1.battleCard && GameState.player2.battleCard) {
                    document.getElementById('networkWaitingOverlay').classList.remove('active');
                    startBattle();
                }
            } else if (action.type === 'do_action') {
                doAction(action.actionType, action.skillIdx, true);
            } else if (action.type === 'retreat') {
                BattleSystem.retreat(opponentKey, action.skillIdx);
                updateUI();
                GameState.endTurn();
                updateUI();
            } else if (action.type === 'replace_death') {
                const player = GameState[opponentKey];
                player.battleCard = player.standbyCards.splice(action.skillIdx, 1)[0];
                GameState.addLog(`${player.name} æ´¾é£ ${player.battleCard.name} ä¸Šå ´ï¼`, 'status');

                const modal = document.getElementById('replacementModal');
                modal.classList.remove('active');

                updateUI();
                updateBattleLog();
                if (window.resolveRemoteReplacement) {
                    window.resolveRemoteReplacement();
                    window.resolveRemoteReplacement = null;
                }
            } else if (action.type === 'emoji' && window.Animations) {
                if (window.Animations.showEmoji) {
                    window.Animations.showEmoji(action.emojiId, opponentKey);
                }
            }
        }

        document.getElementById('confirmSelection').onclick = async function () {
            if (selectedBattleCard === null) return;

            const currentPlayerKey = selectionPhase.startsWith('p1') || selectionPhase.startsWith('player1') ? 'player1' : 'player2';
            const otherPlayerKey = currentPlayerKey === 'player1' ? 'player2' : 'player1';

            GameState.setBattleCard(currentPlayerKey, selectedBattleCard);

            if (GameState.mode === 'online') {
                // Send our pick to the opponent
                NetManager.sendAction({ type: 'select_initial', cardIdx: selectedBattleCard });

                // If opponent hasn't picked yet, show waiting screen
                if (!GameState[otherPlayerKey].battleCard) {
                    renderWaitingForOpponentSelection();
                } else {
                    document.getElementById('networkWaitingOverlay').classList.remove('active');
                    startBattle(); // Both selected
                }
                return;
            }

            if ((GameState.mode === 'story' || GameState.type === 'pve') && currentPlayerKey === 'player1') {
                if (GameState.mode === 'story') {
                    // In story mode, opponent (NPC) automatically selects the first card
                    const npcPick = 0;
                    GameState.setBattleCard('player2', npcPick);
                    GameState.addLog(`[NPC] ç©å®¶2 è‡ªå‹•é¸æ“‡äº† ${GameState.player2.battleCard.name} ä½œç‚ºé¦–ç™¼ã€‚`, 'status');
                } else {
                    GameState.addLog(`[NPC] ${GameState.player2.name} æ´¾å‡ºäº† ${GameState.player2.battleCard.name} ä½œç‚ºé¦–ç™¼ã€‚`, 'status');
                }
                startBattle();
                return;
            }

            // In classic mode, check if both players have selected their cards
            const firstPlayerKey = GameState.firstPlayer === 1 ? 'player1' : 'player2';

            if (currentPlayerKey === firstPlayerKey) {
                // First player has chosen, now second player's turn
                selectionPhase = otherPlayerKey + '_draw';
                await startDrawPhase(otherPlayerKey);
            } else {
                // Second player has chosen, start battle
                startBattle();
            }
        };

        function startBattle() {
            document.getElementById('selectionPhase').classList.add('hidden');
            document.getElementById('battleContainer').style.display = 'flex';
            GameState.phase = 'battle';
            GameState.turnCount = 1;

            // Flip perspective for Host so P1 appears at the bottom/right.
            // Joiner is P2, so P2 is naturally at bottom/right.
            if (GameState.mode === 'online' && localStorage.getItem('onlineRole') === 'host') {
                document.getElementById('battleContainer').classList.add('flip-perspective');
            } else {
                document.getElementById('battleContainer').classList.remove('flip-perspective');
            }

            updateUI();
            GameState.addLog('æˆ°é¬¥é–‹å§‹ï¼', 'skill');
            updateBattleLog();

            // Trigger AI if it's Player 2's turn in story or pve
            if ((GameState.mode === 'story' || GameState.type === 'pve') && GameState.currentPlayer === 2) {
                setTimeout(playAITurn, 1200); // Wait a bit before AI acts
            }
        }

        function updateUI() {
            // Update turn indicator
            document.getElementById('turnCount').textContent = GameState.turnCount;

            // Update player names
            const p1NameElem = document.querySelector('#player1Area .player-name');
            const p2NameElem = document.querySelector('#player2Area .player-name');
            if (p1NameElem) p1NameElem.textContent = GameState.player1.name;
            if (p2NameElem) p2NameElem.textContent = GameState.player2.name;

            // Reset mobile view on UI update
            isShowingOpponent = false;
            const container = document.getElementById('battleContainer');
            const toggleBtn = document.getElementById('mobileToggleBtn');
            if (container) container.classList.remove('show-opponent-mobile');
            if (toggleBtn) toggleBtn.textContent = 'æŸ¥çœ‹å°æ‰‹';

            // Update player cards
            updatePlayerCard('player1', 'p1');
            updatePlayerCard('player2', 'p2');

            // Show/hide action buttons based on current player
            const isP1Turn = GameState.currentPlayer === 1;
            const isPvE = GameState.mode === 'story' || GameState.type === 'pve';
            const isOnline = GameState.mode === 'online';
            const localRole = window.localOnlineRole || 'host'; // Fix: Read from memory, not localStorage to avoid cross-tab pollution
            const isLocalP1 = !isOnline || localRole === 'host';
            const isLocalP2 = !isOnline || localRole === 'join';

            document.getElementById('p1TurnBadge').classList.toggle('hidden', !isP1Turn);
            document.getElementById('p2TurnBadge').classList.toggle('hidden', isP1Turn);

            // Update Skill Button state
            document.getElementById('p1SkillBtn').disabled = !isP1Turn;
            document.getElementById('p2SkillBtn').disabled = isP1Turn;

            // Highlight active player
            document.getElementById('player1Area').classList.toggle('active-turn', isP1Turn);
            document.getElementById('player2Area').classList.toggle('active-turn', !isP1Turn);

            // Re-enable buttons for the active player (fix for buttons sticking disabled)
            const p1Btns = document.querySelectorAll('#p1Actions .action-btn:not(.view-skill-btn)');
            const p2Btns = document.querySelectorAll('#p2Actions .action-btn:not(.view-skill-btn)');
            const p1SkillBtn = document.getElementById('p1SkillBtn');
            const p2SkillBtn = document.getElementById('p2SkillBtn');
            const p1ViewBtn = document.getElementById('p1ViewSkillBtn');
            const p2ViewBtn = document.getElementById('p2ViewSkillBtn');

            if (isP1Turn) {
                p1Btns.forEach(btn => btn.disabled = false);
                p2Btns.forEach(btn => btn.disabled = true);
                if (GameState.player1.battleCard && GameState.player1.battleCard.passive?.effect?.action === 'no_attack_dot_revive') {
                    const attackBtn = document.querySelector('#p1Actions .attack-btn');
                    if (attackBtn) attackBtn.disabled = true;
                }
            } else {
                p1Btns.forEach(btn => btn.disabled = true);
                p2Btns.forEach(btn => btn.disabled = false);
                if (!isPvE) {
                    if (GameState.player2.battleCard && GameState.player2.battleCard.passive?.effect?.action === 'no_attack_dot_revive') {
                        const attackBtn = document.querySelector('#p2Actions .attack-btn');
                        if (attackBtn) attackBtn.disabled = true;
                    }
                }
            }

            // View skill btn is always enabled if it's visible
            p1ViewBtn.disabled = false;
            p2ViewBtn.disabled = false;

            // Handle View Skill Button Visibility & Action Buttons
            // First, reset all action buttons to default visibility (remove inline style)
            Array.from(document.getElementById('p1Actions').children).forEach(child => child.style.display = '');
            Array.from(document.getElementById('p2Actions').children).forEach(child => child.style.display = '');

            // Hide opponent thinking indicators initially
            document.getElementById('p1Thinking').classList.add('hidden');
            document.getElementById('p2Thinking').classList.add('hidden');

            // Online Mode Overrides: Hide opponent's buttons entirely
            if (isOnline) {
                if (localRole === 'host') {
                    // Host is P1. Cannot click P2 actions.
                    document.getElementById('p2Actions').style.display = 'none';
                    if (!isP1Turn) {
                        p1Btns.forEach(btn => btn.disabled = true);
                        p1SkillBtn.disabled = true;
                        p1ViewBtn.classList.remove('hidden');
                        p1ViewBtn.setAttribute('onclick', "openViewSkillModal('player2')");

                        // Opponent is thinking
                        const thinkingUI = document.getElementById('p2Thinking');
                        thinkingUI.classList.remove('hidden');
                        thinkingUI.innerHTML = 'æ€è€ƒä¸­<span class="thinking-dots"><span>.</span><span>.</span><span>.</span></span>';
                    } else {
                        p1ViewBtn.classList.add('hidden');
                    }
                } else if (localRole === 'join') {
                    // Joiner is P2. Cannot click P1 actions.
                    document.getElementById('p1Actions').style.display = 'none';
                    if (isP1Turn) {
                        p2Btns.forEach(btn => btn.disabled = true);
                        p2SkillBtn.disabled = true;
                        p2ViewBtn.classList.remove('hidden');
                        p2ViewBtn.setAttribute('onclick', "openViewSkillModal('player1')");

                        // Opponent is thinking
                        const thinkingUI = document.getElementById('p1Thinking');
                        thinkingUI.classList.remove('hidden');
                        thinkingUI.innerHTML = 'æ€è€ƒä¸­<span class="thinking-dots"><span>.</span><span>.</span><span>.</span></span>';
                    } else {
                        p2ViewBtn.classList.add('hidden');
                    }
                }
            } else {
                // Classic / PvE Logic
                if (isP1Turn) {
                    // Player 1's turn
                    document.getElementById('p1Actions').style.display = 'flex';
                    p1ViewBtn.classList.add('hidden'); // P1 doesn't need view skill btn for themselves

                    // Show view skill button for P2
                    document.getElementById('p2Actions').style.display = 'flex';
                    p2ViewBtn.classList.remove('hidden');

                    // Keep P2 area visible (action area), but hide P2's actual action buttons
                    Array.from(document.getElementById('p2Actions').children).forEach(child => {
                        if (child.id !== 'p2ViewSkillBtn') {
                            child.style.display = 'none';
                        }
                    });
                } else {
                    // Player 2's turn
                    p2ViewBtn.classList.add('hidden'); // P2 doesn't need view skill btn for themselves

                    if (isPvE) {
                        // P2 is NPC, hide entire actions area
                        document.getElementById('p2Actions').style.display = 'none';
                        // NPC doesn't need to view P1's skills either
                        document.getElementById('p1Actions').style.display = 'none';
                        p1ViewBtn.classList.add('hidden');
                    } else {
                        // P2 can view P1's skills
                        document.getElementById('p1Actions').style.display = 'flex';
                        p1ViewBtn.classList.remove('hidden');

                        // Hide P1's actual action buttons
                        Array.from(document.getElementById('p1Actions').children).forEach(child => {
                            if (child.id !== 'p1ViewSkillBtn') {
                                child.style.display = 'none';
                            }
                        });

                        // P2 is Player, show normal buttons
                        document.getElementById('p2Actions').style.display = 'flex';
                    }
                }
            }
        }

        function updatePlayerCard(playerKey, prefix) {
            const player = GameState[playerKey];
            const card = player.battleCard;

            if (!card) {
                document.getElementById(`${prefix}CharName`).textContent = 'ç„¡è§’è‰²';
                return;
            }

            document.getElementById(`${prefix}CharName`).textContent = card.name;
            document.getElementById(`${prefix}CharRarity`).textContent = getRarityName(card.rarity);
            document.getElementById(`${prefix}CharRarity`).className = `battle-char-rarity ${getRarityClass(card.rarity)}`;

            // HP bar
            const hpPercent = Math.max(0, Math.min(100, (card.hp / card.maxHp) * 100));
            document.getElementById(`${prefix}HpBar`).style.width = hpPercent + '%';
            document.getElementById(`${prefix}HpText`).textContent = `${Math.max(0, card.hp)} / ${card.maxHp}`;

            // Shield bar
            const shieldPercent = Math.min(100, (card.shield / card.maxHp) * 100);
            document.getElementById(`${prefix}ShieldBar`).style.width = shieldPercent + '%';
            document.getElementById(`${prefix}Shield`).textContent = card.shield;

            // ATK
            document.getElementById(`${prefix}Atk`).textContent = card.atk;

            // Status effects & Resources
            const statusDiv = document.getElementById(`${prefix}Status`);
            statusDiv.innerHTML = '';

            // 1. Status Effects
            card.statusEffects.forEach(effect => {
                const badge = document.createElement('span');
                badge.className = `status-badge ${effect.type}`;
                let text = effect.name || effect.type;

                if (effect.turns && effect.turns > 0 && !effect.permanent) {
                    text += ` (${effect.turns}å›)`;
                } else if (effect.permanent) {
                    text += ` (âˆ)`;
                }

                if (effect.hits !== undefined) {
                    text += ` [${effect.hits}æ¬¡]`;
                } else if (effect.value !== undefined && effect.type !== 'dot' && effect.type !== 'poison' && effect.type !== 'burn') {
                    text += `: ${effect.value}`;
                } else if (effect.chance !== undefined) {
                    text += ` ${effect.chance}%`;
                }

                badge.textContent = text;
                statusDiv.appendChild(badge);
            });

            // 2. Resources (Combo, stacks, etc.)
            if (card.resources) {
                Object.entries(card.resources).forEach(([key, value]) => {
                    const badge = document.createElement('span');
                    badge.className = 'status-badge resource';
                    badge.style.background = 'rgba(0, 255, 255, 0.2)';
                    badge.style.color = '#fff';
                    badge.textContent = `${key}: ${value}`;
                    statusDiv.appendChild(badge);
                });
            }

            // Passive
            const passiveDiv = document.getElementById(`${prefix}Passive`);
            if (card.passive) {
                passiveDiv.innerHTML = `
                <div style="font-size: 0.8rem; color: var(--neon-gold); margin: 5px 0; text-align: left; padding: 5px; background: rgba(255, 215, 0, 0.1); border-radius: 4px;">
                    <div style="font-weight: bold; margin-bottom: 2px;">è¢«å‹•: ${card.passive.name}</div>
                    <div style="color: #ddd; line-height: 1.2;">${card.passive.desc || 'ç„¡æè¿°'}</div>
                </div>`;
            } else {
                passiveDiv.innerHTML = '';
            }

            // Standby cards
            const standbyDiv = document.getElementById(`${prefix}Standby`);
            standbyDiv.innerHTML = '';
            player.standbyCards.forEach((c, idx) => {
                const div = document.createElement('div');
                div.className = `standby-card glass ${getRarityClass(c.rarity)}`;

                // Show name
                let contentHTML = `<div>${c.name}</div>`;

                // Show cooldowns if any
                if (c.skills && c.cooldowns) {
                    let cdHTML = '';
                    c.skills.forEach((skill, sIdx) => {
                        if (c.cooldowns[sIdx] > 0) {
                            cdHTML += `<div style="font-size: 0.7rem; color: #ff6b6b; margin-top: 2px;">${skill.name} CD: ${c.cooldowns[sIdx]}</div>`;
                        }
                    });
                    if (cdHTML) {
                        contentHTML += cdHTML;
                    }
                }

                div.innerHTML = contentHTML;
                div.onclick = () => showCardDetails(c); // Click to view details
                standbyDiv.appendChild(div);
            });
        }

        function openSkillModal(playerKey) {
            const player = GameState[playerKey];
            const card = player.battleCard;
            if (!card) return;

            const modal = document.getElementById('skillPanelModal');
            const options = document.getElementById('skillModalOptions');
            const title = document.getElementById('skillModalTitle');

            title.textContent = `${player.name} - ä½¿ç”¨æŠ€èƒ½`;
            options.innerHTML = '';

            const isMyTurn = (playerKey === 'player1' && GameState.currentPlayer === 1) ||
                (playerKey === 'player2' && GameState.currentPlayer === 2);

            if (card.skills) {
                card.skills.forEach((skill, idx) => {
                    const btn = document.createElement('button');
                    btn.className = 'skill-btn-modal';
                    // Strict disable: Not my turn OR cooldown OR silence
                    const onCooldown = card.cooldowns[idx] > 0;
                    const isSilenced = card.statusEffects.some(e => e.type === 'silence');
                    btn.disabled = !isMyTurn || onCooldown || isSilenced;

                    btn.innerHTML = `
                        <div class="skill-name-modal">${skill.name}</div>
                        <div class="skill-desc-modal">${skill.desc || 'ç„¡æè¿°'}</div>
                        <div class="skill-footer-modal">
                            <span class="skill-cd-modal">${onCooldown ? `å†·å»ä¸­: ${card.cooldowns[idx]}` : `å†·å»: ${skill.cd}`}</span>
                            ${isSilenced ? '<span class="skill-silence-modal">è¢«æ²‰é»˜</span>' : ''}
                        </div>
                    `;

                    btn.onclick = async () => {
                        closeSkillModal();
                        await doAction('skill', idx);
                    };
                    options.appendChild(btn);
                });
            }
            modal.classList.add('active');

            if (GameState.mode === 'online') {
                NetManager.sendState({ type: 'thinking', isThinking: true });
            }
        }

        function closeSkillModal() {
            document.getElementById('skillPanelModal').classList.remove('active');
            if (GameState.mode === 'online') {
                NetManager.sendState({ type: 'thinking', isThinking: false });
            }
        }

        function openViewSkillModal(playerKey) {
            const player = GameState[playerKey];
            const card = player.battleCard;
            if (!card) return;

            const modal = document.getElementById('viewSkillPanelModal');
            const options = document.getElementById('viewSkillModalOptions');
            const title = document.getElementById('viewSkillModalTitle');

            title.textContent = `æŸ¥çœ‹ ${player.name} (${card.name}) çš„æŠ€èƒ½`;
            options.innerHTML = '';

            if (card.skills) {
                card.skills.forEach((skill, idx) => {
                    const btn = document.createElement('button');
                    btn.className = 'skill-btn-modal';
                    btn.disabled = true; // Always disabled, view only

                    const onCooldown = card.cooldowns[idx] > 0;
                    const isSilenced = card.statusEffects.some(e => e.type === 'silence');

                    btn.innerHTML = `
                        <div class="skill-name-modal">${skill.name}</div>
                        <div class="skill-desc-modal">${skill.desc || 'ç„¡æè¿°'}</div>
                        <div class="skill-footer-modal">
                            <span class="skill-cd-modal">${onCooldown ? `å†·å»ä¸­: ${card.cooldowns[idx]}` : `å†·å»: ${skill.cd}`}</span>
                            ${isSilenced ? '<span class="skill-silence-modal">è¢«æ²‰é»˜</span>' : ''}
                        </div>
                    `;

                    options.appendChild(btn);
                });
            }
            modal.classList.add('active');
        }

        function closeViewSkillModal() {
            document.getElementById('viewSkillPanelModal').classList.remove('active');
        }

        function updateBattleLog() {
            const logDiv = document.getElementById('battleLog');
            logDiv.innerHTML = '';
            GameState.battleLog.slice(0, 15).forEach(entry => {
                const div = document.createElement('div');
                div.className = `log-entry log-${entry.type}`;
                div.textContent = entry.message;
                logDiv.appendChild(div);
            });
        }

        async function doAction(type, skillIndex = null, isRemote = false) {
            if (isProcessing) return;
            isProcessing = true;

            if (!isRemote && GameState.mode === 'online') {
                NetManager.sendAction({ type: 'do_action', actionType: type, skillIdx: skillIndex });
            }

            // Disable buttons visually
            document.querySelectorAll('.action-btn').forEach(btn => btn.disabled = true);

            try {
                const playerKey = GameState.currentPlayer === 1 ? 'player1' : 'player2';
                const opponentKey = GameState.currentPlayer === 1 ? 'player2' : 'player1';
                const attacker = GameState[playerKey].battleCard;
                const defender = GameState[opponentKey].battleCard;

                if (!attacker || !defender) return;

                if (type === 'attack') {
                    await BattleSystem.normalAttack(attacker, defender);
                } else if (type === 'skill') {
                    await BattleSystem.useSkill(attacker, defender, skillIndex); // Await async skill
                }

                updateUI();
                updateBattleLog();

                // Check for deaths
                const playersToCheck = ['player1', 'player2'];
                for (const p of playersToCheck) {
                    const card = GameState[p].battleCard;
                    if (card && card.hp <= 0) {
                        const died = await GameState.handleDeath(p);
                        if (died) {
                            GameState.addLog(`${card.name} è¢«æ“Šæ•—ï¼`, 'damage');
                            updateUI();
                            updateBattleLog();

                            // If there are standby cards, must pick one
                            if (GameState[p].standbyCards.length > 0) {
                                if (GameState.mode === 'online') {
                                    const isLocalPlayer = (NetManager.isHost && p === 'player1') || (!NetManager.isHost && p === 'player2');
                                    if (isLocalPlayer) {
                                        await promptReplacement(p);
                                    } else {
                                        // Wait for remote action 'replace_death'
                                        document.getElementById('networkWaitingTitle').textContent = 'ç­‰å¾…å°æ‰‹æ›¿æ›è§’è‰²...';
                                        document.getElementById('networkWaitingText').textContent = 'å°æ‰‹æ­£åœ¨è€ƒæ…®è¦æ´¾èª°ä¸Šå ´';
                                        document.getElementById('networkRoomCode').classList.add('hidden');
                                        document.getElementById('networkWaitingOverlay').classList.remove('hidden');
                                        await new Promise(resolve => window.resolveRemoteReplacement = resolve);
                                        document.getElementById('networkWaitingOverlay').classList.add('hidden');
                                    }
                                } else {
                                    await promptReplacement(p);
                                }
                            }
                        }
                    }
                }

                // Check win
                if (GameState.checkWin()) {
                    await Animations.victory(GameState.winner === 1 ? 'ç©å®¶1' : 'ç©å®¶2');
                    return;
                }

                // End turn
                GameState.endTurn();
                updateUI();
                updateBattleLog();

                // Trigger AI if it's Player 2's turn in story mode or PvE
                if ((GameState.mode === 'story' || GameState.type === 'pve') && GameState.currentPlayer === 2) {
                    setTimeout(playAITurn, 1200); // Wait a bit before AI acts
                }

            } finally {
                isProcessing = false;
                // Buttons will be re-enabled by updateUI based on turn state
                updateUI();
            }
        }

        // --- NPC AI Logic ---
        async function playAITurn() {
            if (GameState.winner !== null || GameState.currentPlayer !== 2) return;

            const card = GameState.player2.battleCard;
            if (!card) return; // Should not happen if replacement works

            // If stunned or sleeping, status effects are already processed by endTurn -> next turn start Of Turn.
            // Wait, startOfTurn might skip the turn immediately. We need to verify if it's still player 2's turn.
            if (GameState.currentPlayer !== 2) {
                // If it skipped to player 1
                return;
            }

            // Show thinking indicator
            const thinkingUI = document.getElementById('p2Thinking');
            if (thinkingUI) thinkingUI.classList.remove('hidden');

            // Simulate thinking time (random between 1 to 2.5 seconds)
            const thinkTime = Math.floor(Math.random() * 1500) + 1000;

            setTimeout(async () => {
                const availableSkills = [];
                if (card.skills) {
                    // Check silence
                    const isSilenced = card.statusEffects.some(e => e.type === 'silence');
                    if (!isSilenced) {
                        card.skills.forEach((skill, idx) => {
                            if (card.cooldowns[idx] <= 0) {
                                availableSkills.push(idx);
                            }
                        });
                    }
                }

                const difficulty = localStorage.getItem('pveDifficulty') || 'normal';

                let actionType = 'attack';
                let skillIdx = null;

                // Smart AI Decisions based on difficulty
                if (difficulty === 'hell') {
                    // Try to retreat if low HP and have healthy standby
                    const hpPercent = card.hp / card.maxHp;
                    const opponentHpPercent = GameState.player1.battleCard ? GameState.player1.battleCard.hp / GameState.player1.battleCard.maxHp : 1;

                    // More aggressive retreat: 100% chance if HP < 35% and opponent is not close to dying
                    if (hpPercent < 0.35 && opponentHpPercent > 0.2 && GameState.player2.standbyCards.length > 0) {
                        const healthyStandbys = GameState.player2.standbyCards.filter(c => c.hp / c.maxHp > 0.5);
                        if (healthyStandbys.length > 0) {
                            let bestIdx = 0;
                            let maxScore = 0;
                            GameState.player2.standbyCards.forEach((c, i) => {
                                const baseAtk = typeof c.atk === 'object' ? Math.floor((c.atk.min + c.atk.max) / 2) : c.atk;
                                const score = c.hp + (baseAtk * 10);
                                if (score > maxScore) { maxScore = score; bestIdx = i; }
                            });
                            actionType = 'retreat';
                            skillIdx = bestIdx;
                        }
                    }

                    if (actionType !== 'retreat') {
                        const expectedAtk = typeof card.atk === 'object' ? Math.floor((card.atk.min + card.atk.max) / 2) : card.atk;
                        const opponentCard = GameState.player1.battleCard;
                        const totalOpponentHp = opponentCard ? (opponentCard.hp + opponentCard.shield) : 9999;

                        // Categorize available skills
                        const defensiveSkills = availableSkills.filter(idx =>
                            card.skills[idx].desc.includes('ä¿è­·') ||
                            card.skills[idx].desc.includes('æ¢å¾©') ||
                            card.skills[idx].desc.includes('è­·ç›¾') ||
                            card.skills[idx].desc.includes('ç„¡æ•µ') ||
                            card.skills[idx].desc.includes('ç”Ÿå‘½')
                        );
                        const offensiveSkills = availableSkills.filter(idx =>
                            !defensiveSkills.includes(idx) && (
                                card.skills[idx].desc.includes('å‚·å®³') ||
                                card.skills[idx].desc.includes('æ”»æ“Š') ||
                                card.skills[idx].desc.includes('æšˆçœ©') ||
                                card.skills[idx].desc.includes('ä¸­æ¯’') ||
                                card.skills[idx].desc.includes('ç‡ƒç‡’')
                            )
                        );
                        const otherSkills = availableSkills.filter(idx => !defensiveSkills.includes(idx) && !offensiveSkills.includes(idx));

                        // 1. Kill confirmed with normal attack & we aren't about to die
                        if (totalOpponentHp <= expectedAtk && hpPercent > 0.3) {
                            actionType = 'attack';
                        }
                        // 2. High priority: Defensive skills when HP is low
                        else if (hpPercent < 0.65 && defensiveSkills.length > 0) {
                            actionType = 'skill';
                            skillIdx = defensiveSkills[Math.floor(Math.random() * defensiveSkills.length)];
                        }
                        // 3. Offensive skills when opponent has enough HP to warrant it
                        else if (offensiveSkills.length > 0 && totalOpponentHp > expectedAtk) {
                            actionType = 'skill';
                            skillIdx = offensiveSkills[Math.floor(Math.random() * offensiveSkills.length)];
                        }
                        // 4. Other skills (buffs, etc.) with a high chance
                        else if (otherSkills.length > 0 && Math.random() < 0.8) {
                            actionType = 'skill';
                            skillIdx = otherSkills[Math.floor(Math.random() * otherSkills.length)];
                        }
                        // 5. Default to attack (e.g., HP is high so we skip defensive skills, or no skills left)
                        else {
                            actionType = 'attack';
                        }
                    }
                } else if (difficulty === 'hard') {
                    // Try to retreat if low HP and have healthy standby
                    const hpPercent = card.hp / card.maxHp;
                    if (hpPercent < 0.3 && GameState.player2.standbyCards.length > 0) {
                        const healthyStandbys = GameState.player2.standbyCards.filter(c => c.hp / c.maxHp > 0.6);
                        if (healthyStandbys.length > 0 && Math.random() < 0.8) { // 80% retreat chance when low HP
                            // Find the one with highest HP
                            let bestIdx = 0;
                            let maxHp = 0;
                            GameState.player2.standbyCards.forEach((c, i) => {
                                if (c.hp > maxHp) { maxHp = c.hp; bestIdx = i; }
                            });
                            actionType = 'retreat';
                            skillIdx = bestIdx;
                        }
                    }

                    if (actionType !== 'retreat') {
                        if (availableSkills.length > 0) {
                            // Hard mode prioritizes skills whenever possible
                            actionType = 'skill';
                            // Prioritize healing/shield if low HP (e.g., skill name contains keywords)
                            if (hpPercent < 0.5) {
                                const defensiveSkills = availableSkills.filter(idx =>
                                    card.skills[idx].desc.includes('ä¿è­·') ||
                                    card.skills[idx].desc.includes('æ¢å¾©') ||
                                    card.skills[idx].desc.includes('è­·ç›¾') ||
                                    card.skills[idx].desc.includes('ç„¡æ•µ')
                                );
                                if (defensiveSkills.length > 0) {
                                    skillIdx = defensiveSkills[Math.floor(Math.random() * defensiveSkills.length)];
                                } else {
                                    skillIdx = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                                }
                            } else {
                                skillIdx = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                            }
                        } else {
                            actionType = 'attack';
                        }
                    }
                } else if (difficulty === 'easy') {
                    // Easy mode: Never retreats. 50% chance to forget to use skills.
                    if (availableSkills.length > 0 && Math.random() < 0.5) {
                        actionType = 'skill';
                        skillIdx = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                    } else {
                        actionType = 'attack';
                    }
                } else {
                    // Default logic for 'normal' difficulty
                    if (availableSkills.length > 0 && Math.random() < 0.6) {
                        actionType = 'skill';
                        skillIdx = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                    } else {
                        actionType = 'attack';
                    }
                }

                // If character cannot attack, force skill if available
                if (actionType === 'attack' && card.passive?.effect?.action === 'no_attack_dot_revive') {
                    if (availableSkills.length > 0) {
                        actionType = 'skill';
                        // Pick any available skill
                        skillIdx = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                    } else {
                        // If no skills available and can't attack, just skip turn by trying to do an empty action or retreat if possible
                        // Here we just map it back to attack which will be blocked and skip effectively by passing the turn.
                        // Since normalAttack already blocks 'no_attack_dot_revive' logging "Cannot attack", 
                        // it won't crash, but it's an elegant way to skip a turn natively.
                    }
                }

                if (thinkingUI) thinkingUI.classList.add('hidden');

                if (actionType === 'retreat') {
                    GameState.addLog(`[NPC] èªç‚ºæƒ…å‹¢ä¸åˆ©ï¼Œé¸æ“‡æ’¤æ›è§’è‰²ç‚º ${GameState.player2.standbyCards[skillIdx].name}`, 'status');
                } else {
                    GameState.addLog(`[NPC] æ±ºå®šä½¿ç”¨ ${actionType === 'skill' ? card.skills[skillIdx].name : 'æ™®æ”»'}`, 'status');
                }
                updateBattleLog();

                setTimeout(async () => {
                    if (actionType === 'retreat') {
                        BattleSystem.retreat('player2', skillIdx);
                        updateUI();
                        GameState.endTurn();
                        updateUI();
                    } else {
                        await doAction(actionType, skillIdx);
                    }
                }, 400); // Short delay before executing to make log visible
            }, thinkTime);
        }
        // --------------------

        function promptReplacement(playerKey) {
            return new Promise((resolve) => {
                const player = GameState[playerKey];

                // --- Story / PvE mode AI check for replacements ---
                if ((GameState.mode === 'story' || GameState.type === 'pve') && playerKey === 'player2') {
                    const difficulty = localStorage.getItem('pveDifficulty') || 'normal';

                    if (player.standbyCards.length > 0) {
                        setTimeout(() => {
                            let pickIdx = 0;

                            // Hard & Hell mode picks the best character (highest combined HP+ATK)
                            if (difficulty === 'hard' || difficulty === 'hell') {
                                let maxScore = 0;
                                player.standbyCards.forEach((c, idx) => {
                                    const baseAtk = typeof c.atk === 'object' ? Math.floor((c.atk.min + c.atk.max) / 2) : c.atk;
                                    const score = c.hp + (baseAtk * 10);
                                    if (score > maxScore) {
                                        maxScore = score;
                                        pickIdx = idx;
                                    }
                                });
                            }

                            player.battleCard = player.standbyCards.splice(pickIdx, 1)[0];
                            GameState.addLog(`[NPC] ${player.name} è‡ªå‹•æ›¿æ› ${player.battleCard.name} ä¸Šå ´ï¼`, 'status');
                            updateUI();
                            updateBattleLog();
                            resolve();
                        }, 1000); // Small delay for visual pacing
                        return;
                    }
                }
                // --------------------------------------------

                const modal = document.getElementById('replacementModal');
                const optionsDiv = document.getElementById('replacementOptions');
                const title = document.getElementById('replacementTitle');

                title.textContent = `${player.name} çš„è§’è‰²å·²é™£äº¡ï¼è«‹é¸æ“‡æ›¿æ›è§’è‰²`;
                optionsDiv.innerHTML = '';
                modal.classList.add('active');

                player.standbyCards.forEach((card, idx) => {
                    const div = document.createElement('div');
                    div.className = `select-card glass ${getRarityClass(card.rarity)}`;
                    div.innerHTML = renderCardInfo(card);

                    div.onclick = () => {
                        if (GameState.mode === 'online') {
                            NetManager.sendAction({ type: 'replace_death', skillIdx: idx });
                        }

                        // Perform the swap (remove from standby, set as battle)
                        player.battleCard = player.standbyCards.splice(idx, 1)[0];
                        GameState.addLog(`${player.name} æ´¾é£ ${player.battleCard.name} ä¸Šå ´ï¼`, 'status');

                        modal.classList.remove('active');
                        updateUI();
                        updateBattleLog();
                        resolve();
                    };
                    optionsDiv.appendChild(div);
                });
            });
        }

        function showRetreat() {
            if (isProcessing) return;
            const playerKey = GameState.currentPlayer === 1 ? 'player1' : 'player2';
            const player = GameState[playerKey];

            if (player.standbyCards.length === 0) {
                GameState.addLog('å‚™æˆ°å€æ²’æœ‰è§’è‰²å¯æ›¿æ›ï¼', 'status');
                updateBattleLog();
                return;
            }

            const optionsDiv = document.getElementById('retreatOptions');
            optionsDiv.innerHTML = '';

            player.standbyCards.forEach((card, idx) => {
                const div = document.createElement('div');
                div.className = `select-card glass ${getRarityClass(card.rarity)}`;
                div.innerHTML = renderCardInfo(card);

                div.onclick = () => {
                    if (GameState.mode === 'online') {
                        NetManager.sendAction({ type: 'retreat', skillIdx: idx });
                    }

                    BattleSystem.retreat(playerKey, idx);
                    closeRetreatModal();
                    updateUI();
                    updateBattleLog();
                    GameState.endTurn();
                    updateUI();

                    // Trigger AI if it's Player 2's turn in story mode or PvE
                    if ((GameState.mode === 'story' || GameState.type === 'pve') && GameState.currentPlayer === 2) {
                        setTimeout(playAITurn, 1200); // Wait a bit before AI acts
                    }
                };
                optionsDiv.appendChild(div);
            });

            document.getElementById('retreatModal').classList.add('active');
        }

        function closeRetreatModal() {
            document.getElementById('retreatModal').classList.remove('active');
        }

        function showCardDetails(card) {
            const modal = document.getElementById('cardDetailsModal');
            const content = document.getElementById('cardDetailsContent');

            let skillsHtml = '';
            if (card.skills && card.skills.length > 0) {
                skillsHtml = '<div style="margin-top: 15px; text-align: left;">';
                card.skills.forEach(skill => {
                    skillsHtml += `
                        <div style="margin-top: 10px; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
                            <div style="color: var(--neon-cyan); font-weight: bold;">${skill.name} <span style="font-size: 0.8rem; color: #888;">(CD: ${skill.cd})</span></div>
                            <div style="font-size: 0.9rem; color: #ddd; margin-top: 3px;">${skill.desc || 'ç„¡æè¿°'}</div>
                        </div>`;
                });
                skillsHtml += '</div>';
            }

            content.innerHTML = `
                <div class="battle-card-header" style="justify-content: center; margin-bottom: 20px;">
                    <span class="battle-char-name" style="font-size: 2rem;">${card.name}</span>
                </div>
                <div style="display: flex; justify-content: center; gap: 20px; font-size: 1.2rem; margin-bottom: 20px;">
                    <span style="color: #ff6b6b;">HP: ${card.hp}/${card.maxHp}</span>
                    <span style="color: #ffd93d;">ATK: ${typeof card.atk === 'object' ? `${card.atk.min}-${card.atk.max}` : card.atk}</span>
                </div>
                ${card.passive ? `
                    <div style="margin-bottom: 15px; text-align: left; background: rgba(255, 215, 0, 0.1); padding: 10px; border-left: 3px solid var(--neon-gold); border-radius: 4px;">
                        <div style="color: var(--neon-gold); font-weight: bold;">è¢«å‹•: ${card.passive.name}</div>
                        <div style="font-size: 0.9rem; margin-top: 5px;">${card.passive.desc || 'ç„¡æè¿°'}</div>
                    </div>` : ''}
                ${skillsHtml}
                <button class="btn" style="margin-top: 20px; width: 100%;" onclick="document.getElementById('cardDetailsModal').classList.remove('active')">é—œé–‰</button>
            `;

            modal.classList.add('active');
        }

        // Close modal on outside click
        document.getElementById('cardDetailsModal').onclick = (e) => {
            if (e.target.id === 'cardDetailsModal') {
                e.target.classList.remove('active');
            }
        };

        // Emoji Features
        function openEmojiMenu() {
            document.getElementById('emojiModal').classList.add('active');
        }

        function sendEmoji(emoji) {
            document.getElementById('emojiModal').classList.remove('active');

            // Show locally above my own avatar
            const localKey = NetManager.isHost ? 'player1' : 'player2';
            showEmojiAnimation(emoji, localKey);

            // Broadcast to opponent
            NetManager.sendEmoji(emoji);
        }

        function showEmojiAnimation(emoji, playerKey) {
            const containerId = playerKey === 'player1' ? 'player1Area' : 'player2Area';
            const container = document.getElementById(containerId);
            if (!container) return;

            const el = document.createElement('div');
            el.textContent = emoji;
            el.style.position = 'absolute';
            el.style.top = '10%';
            el.style.left = '50%';
            el.style.transform = 'translate(-50%, 0)';
            el.style.fontSize = '4rem';
            el.style.zIndex = '1000';
            el.style.pointerEvents = 'none';
            el.style.animation = 'emojiPoof 2s ease-out forwards';
            el.style.textShadow = '0 0 10px rgba(255,255,255,0.5)';

            container.appendChild(el);

            // Add style locally if it doesn't exist
            if (!document.getElementById('emojiStyle')) {
                const style = document.createElement('style');
                style.id = 'emojiStyle';
                style.textContent = `
                    @keyframes emojiPoof {
                        0% { opacity: 0; transform: translate(-50%, 20px) scale(0.5); }
                        15% { opacity: 1; transform: translate(-50%, -20px) scale(1.2); }
                        30% { transform: translate(-50%, -10px) scale(1.0); }
                        80% { opacity: 1; transform: translate(-50%, -30px) scale(1.0); }
                        100% { opacity: 0; transform: translate(-50%, -50px) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
            }

            setTimeout(() => {
                if (el.parentNode) el.parentNode.removeChild(el);
            }, 2000);
        }

        function finishStoryBattle() {
            if (GameState.winner === 1) {
                unlockNextNode(GameState.currentChapterId, GameState.currentNodeIndex);

                const chapter = STORY_CHAPTERS.find(c => c.id === GameState.currentChapterId);
                const nextIndex = GameState.currentNodeIndex + 1;

                if (nextIndex < chapter.nodes.length) {
                    localStorage.setItem('story_current_node', nextIndex);
                    const nextNode = chapter.nodes[nextIndex];
                    if (nextNode.type === 'dialogue') {
                        location.href = 'story_runner.html';
                    } else if (nextNode.type === 'battle') {
                        location.reload();
                    }
                } else {
                    document.getElementById('storyCompleteModal').classList.add('active');
                }
            } else {
                document.getElementById('storyFailModal').classList.add('active');
            }
        }

        let isProcessing = false;

        // Initialize game
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>

</html>