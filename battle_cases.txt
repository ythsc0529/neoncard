                // --- PART 5 & 6 SKILL EFFECTS ---
                case 'spend_resource_summon':
                    if ((attacker.resources[effect.resource] || 0) >= effect.cost) {
                        attacker.resources[effect.resource] -= effect.cost;
                        const summonTarget = getCharacterByName(effect.target);
                        if (summonTarget) {
                            const inst = createCharacterInstance(summonTarget);
                            GameState.addToStandby(GameState.currentPlayer === 1 ? 'player1' : 'player2', inst);
                            GameState.addLog(`${attacker.name} 消耗 ${effect.cost} ${effect.resource} 召喚了 ${inst.name}！`, 'skill');
                            await Animations.drawCards([inst]);
                        }
                        if (effect.self_destroy) {
                            attacker.hp = 0;
                            GameState.addLog(`${attacker.name} 自我毀滅了！`, 'damage');
                        }
                    } else {
                        GameState.addLog(`${effect.resource} 不足！`, 'status');
                    }
                    break;
                case 'shield_over_time':
                    attacker.statusEffects.push({ type: 'shield_dot', name: '持續護盾', value: effect.shield, turns: effect.turns });
                    GameState.addLog(`${attacker.name} 獲得持續護盾`, 'skill');
                    break;
                case 'damage_and_burn':
                case 'damage_and_burn_percent':
                    await this.applyDamage(attacker, defender, effect.damage || 0);
                    let burnDmg = effect.burn_damage;
                    if (effect.type === 'damage_and_burn_percent') {
                        burnDmg = Math.floor(defender.maxHp * (effect.percent / 100));
                    }
                    defender.statusEffects.push({ type: 'burn', name: '強烈灼燒', damage: burnDmg, turns: effect.turns });
                    GameState.addLog(`${defender.name} 受到灼燒 (${burnDmg}/回合)`, 'status');
                    break;
                case 'immune_hits':
                case 'immune_hits_turns':
                    attacker.statusEffects.push({ type: 'immunity', name: '絕對防禦', hits: effect.hits, turns: effect.turns || 99 });
                    GameState.addLog(`${attacker.name} 獲得 ${effect.hits} 次免疫`, 'skill');
                    break;
                case 'damage_trade_max_hp_percent':
                    const loss = Math.floor(attacker.maxHp * (effect.hp_loss_percent / 100));
                    attacker.maxHp -= loss;
                    attacker.hp = Math.min(attacker.hp, attacker.maxHp);
                    await this.applyDamage(attacker, defender, effect.damage);
                    GameState.addLog(`${attacker.name} 犧牲血量上限造成重擊`, 'skill');
                    break;
                case 'summon_chance_category':
                    if (await Animations.probabilityRoll(effect.chance, '召喚判定')) {
                        const catChar = getRandomFromCategory(effect.category);
                        if (catChar) {
                            const inst = createCharacterInstance(catChar);
                            GameState.addToStandby(GameState.currentPlayer === 1 ? 'player1' : 'player2', inst);
                            GameState.addLog(`成功召喚 ${inst.name}`, 'skill');
                            await Animations.drawCards([inst]);
                        }
                    }
                    break;
                case 'stun_and_resource':
                    defender.statusEffects.push({ type: 'stun', name: '暈眩', turns: effect.turns });
                    if (effect.resource_gain) {
                        attacker.resources[effect.resource_gain] = (attacker.resources[effect.resource_gain] || 0) + effect.gain_amount;
                    }
                    GameState.addLog(`${defender.name} 被暈眩，${attacker.name} 獲得資源`, 'skill');
                    break;
                case 'damage_chance_resource':
                    let baseC = effect.chance;
                    if (effect.resource_scaling) {
                        baseC += (attacker.resources[effect.resource_scaling] || 0) * effect.scale_amount;
                    }
                    if (await Animations.probabilityRoll(baseC, '技能判定')) {
                        await this.applyDamage(attacker, defender, effect.damage);
                    }
                    if (effect.resource_gain) {
                        attacker.resources[effect.resource_gain] = (attacker.resources[effect.resource_gain] || 0) + effect.gain_amount;
                    }
                    break;
                case 'draw_resource':
                    // Just draw normally but name it differently
                    const drawOwner = GameState.currentPlayer === 1 ? 'player1' : 'player2';
                    for (let i = 0; i < effect.count; i++) {
                        const dC = drawRandomCharacter();
                        if (dC) GameState.addToStandby(drawOwner, createCharacterInstance(dC));
                    }
                    GameState.addLog(`${attacker.name} 抽了 ${effect.count} 張牌`, 'skill');
                    break;
                case 'transform_to_enemy_standby':
                    const oppObj = GameState.getOpponent();
                    if (oppObj.standbyCards.length > 0) {
                        const randEnemy = oppObj.standbyCards[Math.floor(Math.random() * oppObj.standbyCards.length)];
                        await this.evolveCharacter(attacker, randEnemy.name);
                    } else {
                        GameState.addLog('敵方備戰區沒有角色可以複製！', 'status');
                    }
                    break;
                case 'damage_multi':
                    for(let i=0; i<effect.hits; i++){
                        await this.applyDamage(attacker, defender, effect.damage);
                    }
                    break;
                case 'dodge_buff':
                    attacker.resources.dodge = (attacker.resources.dodge || 0) + effect.value;
                    GameState.addLog(`${attacker.name} 閃避率增加 ${effect.value}%`, 'skill');
                    break;
                case 'damage_buff_atk_resource':
                    await this.applyDamage(attacker, defender, effect.damage);
                    attacker.atk += effect.atk_buff;
                    attacker.resources[effect.resource] = (attacker.resources[effect.resource] || 0) + effect.resource_amount;
                    GameState.addLog(`造成傷害，攻擊力提升且獲得資源`, 'skill');
                    break;
                case 'damage_heal_resource':
                    await this.applyDamage(attacker, defender, effect.damage);
                    attacker.hp = Math.min(attacker.maxHp, attacker.hp + effect.heal);
                    attacker.resources[effect.resource] = (attacker.resources[effect.resource] || 0) + effect.resource_amount;
                    GameState.addLog(`造成傷害，恢復血量且獲得資源`, 'skill');
                    break;
                case 'domain_expansion':
                    attacker.maxHp += effect.max_hp;
                    attacker.hp += effect.max_hp;
                    attacker.atk += effect.atk;
                    attacker.statusEffects.push({ type: 'immunity', name: '領域展開', hits: 99, turns: effect.turns });
                    GameState.addLog(`${attacker.name} 領域展開！`, 'skill');
                    break;
                case 'copy_enemy_standby':
                    const oppState = GameState.getOpponent();
                    if (oppState.standbyCards.length > 0) {
                        const target = oppState.standbyCards[Math.floor(Math.random() * oppState.standbyCards.length)];
                        const clone = createCharacterInstance(getCharacterByName(target.name));
                        GameState.addToStandby(GameState.currentPlayer === 1 ? 'player1' : 'player2', clone);
                        GameState.addLog(`複製了 ${target.name}！`, 'skill');
                        await Animations.drawCards([clone]);
                    }
                    break;
                case 'clear_enemy_effects':
                    defender.statusEffects = [];
                    defender.atk = defender.baseAtk || 0; // rough approximation of stat reset
                    GameState.addLog(`${defender.name} 的狀態被清除了`, 'skill');
                    break;
                case 'damage_apply_miss_chance':
                    await this.applyDamage(attacker, defender, effect.damage);
                    defender.statusEffects.push({ type: 'miss_chance', name: '致盲', chance: effect.miss_chance, turns: effect.turns });
                    GameState.addLog(`${defender.name} 受到致盲效果`, 'skill');
                    break;
                case 'heal_and_regen':
                    attacker.hp = Math.min(attacker.maxHp, attacker.hp + effect.heal);
                    attacker.statusEffects.push({ type: 'regen', name: '再生', heal: effect.regen, turns: effect.turns });
                    GameState.addLog(`${attacker.name} 恢復並獲得再生效果`, 'heal');
                    break;
                case 'damage_multi_chance':
                    for(let i=0; i<effect.hits; i++){
                        if(await Animations.probabilityRoll(effect.chance, '連擊判定')){
                            await this.applyDamage(attacker, defender, effect.damage);
                        } else {
                            break;
                        }
                    }
                    break;
                case 'damage_or_silence':
                    if (await Animations.probabilityRoll(effect.chance, '判定')) {
                        await this.applyDamage(attacker, defender, effect.damage);
                    } else {
                        defender.statusEffects.push({ type: 'silence', name: '沉默', turns: effect.turns });
                        GameState.addLog(`${defender.name} 被沉默`, 'status');
                    }
                    break;
                case 'execute_chance':
                    if (await Animations.probabilityRoll(effect.chance, '斬殺判定')) {
                        defender.hp = 0;
                        GameState.addLog(`${defender.name} 被直接斬殺！`, 'damage');
                    } else {
                        GameState.addLog('斬殺失敗', 'status');
                    }
                    break;
                case 'buff_atk_heal_enemy':
                    attacker.atk += effect.atk;
                    defender.hp = Math.min(defender.maxHp, defender.hp + effect.enemy_heal);
                    GameState.addLog(`${attacker.name} 攻擊力提升，但 ${defender.name} 恢復了血量`, 'skill');
                    break;
                case 'damage_multi_fixed_chance':
                    for (let i = 0; i < effect.hits; i++) {
                        if (await Animations.probabilityRoll(effect.chance, '多段判定')) {
                            await this.applyDamage(attacker, defender, effect.damage);
                        }
                    }
                    break;
                case 'clear_enemy_dodge':
                    defender.statusEffects = defender.statusEffects.filter(e => e.type !== 'dodge' && e.type !== 'dodge_reflect');
                    if(defender.resources) defender.resources.dodge = 0;
                    GameState.addLog(`${defender.name} 的閃避效果被清除了`, 'skill');
                    break;
                case 'double_next_attack':
                    attacker.nextAttackMult = (attacker.nextAttackMult || 0) + 100;
                    GameState.addLog(`${attacker.name} 下次攻擊傷害加倍`, 'skill');
                    break;
                case 'reflect_next':
                    attacker.statusEffects.push({ type: 'reflect', name: '反彈', value: effect.value || 100, hits: 1 });
                    GameState.addLog(`${attacker.name} 準備反彈下次攻擊`, 'skill');
                    break;
                case 'equalize_hp':
                    const totalHp = attacker.hp + defender.hp;
                    const avgHp = Math.floor(totalHp / 2);
                    attacker.hp = avgHp;
                    defender.hp = avgHp;
                    if(attacker.hp > attacker.maxHp) attacker.maxHp = attacker.hp;
                    if(defender.hp > defender.maxHp) defender.maxHp = defender.hp;
                    GameState.addLog(`雙方生命值被重新分配了！`, 'skill');
                    break;
                case 'peak_state':
                    attacker.hp = effect.hp;
                    attacker.maxHp = Math.max(attacker.maxHp, effect.hp);
                    attacker.atk = effect.atk;
                    attacker.skills.forEach(s => s.cd = 0);
                    attacker.cooldowns.fill(0);
                    GameState.addLog(`${attacker.name} 進入巔峰狀態！`, 'skill');
                    break;
                case 'self_kill_or_add_resource':
                    if (await Animations.probabilityRoll(effect.chance, '副作用判定')) {
                        attacker.hp = 0;
                        GameState.addLog(`${attacker.name} 承受不住力量而死亡`, 'damage');
                    } else {
                        attacker.resources[effect.resource] = (attacker.resources[effect.resource] || 0) + effect.value;
                        GameState.addLog(`獲得 ${effect.resource}`, 'skill');
                    }
                    break;
                case 'damage_enemy_hp_divided_by_resource':
                    const div = (attacker.resources[effect.resource] || 0) + 1; // prevent div by 0
                    const eDmg = Math.floor(defender.hp / div);
                    await this.applyDamage(attacker, defender, eDmg);
                    break;
                case 'execute_chance_if_hp_above':
                    if (defender.hp > defender.maxHp * (effect.threshold / 100)) {
                        if (await Animations.probabilityRoll(effect.chance, '收割判定')) {
                            defender.hp = 0;
                            GameState.addLog(`${defender.name} 被強制收割！`, 'damage');
                        }
                    }
                    else { GameState.addLog('條件不符', 'status'); }
                    break;
                case 'buff_atk_mult_chance':
                    if (await Animations.probabilityRoll(effect.chance, '強化判定')) {
                        attacker.atk = Math.floor(attacker.atk * effect.mult);
                        GameState.addLog(`${attacker.name} 攻擊力翻倍！`, 'skill');
                    }
                    break;
                case 'immune_status_effects':
                    attacker.statusEffects.push({ type: 'immune_status', name: '狀態免疫', turns: effect.turns });
                    GameState.addLog(`${attacker.name} 獲得狀態異常免疫`, 'skill');
                    break;
                case 'debuff_enemy_atk_half_chance':
                    if (await Animations.probabilityRoll(effect.chance, '削弱判定')) {
                        defender.atk = Math.floor(defender.atk / 2);
                        GameState.addLog(`${defender.name} 攻擊力減半！`, 'status');
                    }
                    break;
                case 'damage_doubling':
                    for(let i=0; i<effect.attacks; i++){
                        await this.applyDamage(attacker, defender, effect.start_damage * Math.pow(2, i));
                    }
                    break;
                case 'debuff_enemy_stats_percent':
                    defender.maxHp = Math.floor(defender.maxHp * ((100-effect.percent)/100));
                    if(defender.hp > defender.maxHp) defender.hp = defender.maxHp;
                    defender.atk = Math.floor(defender.atk * ((100-effect.percent)/100));
                    GameState.addLog(`${defender.name} 屬性大幅下降`, 'status');
                    break;
                case 'remove_random_standby_both':
                    {
                        const p1Standby = GameState.player1.standbyCards;
                        const p2Standby = GameState.player2.standbyCards;
                        if(p1Standby.length > 0) {
                            const idx = Math.floor(Math.random() * p1Standby.length);
                            const rm = p1Standby.splice(idx, 1)[0];
                            GameState.addLog(`玩家1的 ${rm.name} 被空間坍方吞噬了！`, 'damage');
                        }
                        if(p2Standby.length > 0) {
                            const idx = Math.floor(Math.random() * p2Standby.length);
                            const rm = p2Standby.splice(idx, 1)[0];
                            GameState.addLog(`玩家2的 ${rm.name} 被空間坍方吞噬了！`, 'damage');
                        }
                    }
                    break;
                case 'apply_blackhole':
                    defender.statusEffects.push({ type: 'blackhole', name: '黑洞', turns: effect.turns });
                    GameState.addLog(`${defender.name} 受到黑洞影響，${effect.turns}回後將被吞噬`, 'skill');
                    break;
                case 'set_stats':
                    if(effect.hp) { attacker.hp = effect.hp; attacker.maxHp = effect.hp; }
                    if(effect.atk !== undefined) { attacker.atk = effect.atk; }
                    GameState.addLog(`${attacker.name} 轉換型態`, 'skill');
                    break;
                case 'immune_enemy_actions':
                    attacker.statusEffects.push({ type: 'immunity_all', name: '無敵', turns: effect.turns });
                    GameState.addLog(`${attacker.name} 進入無敵狀態`, 'skill');
                    break;
                case 'shield_decay':
                    attacker.shield += effect.shield;
                    attacker.statusEffects.push({ type: 'shield_decay', name: '衰減護盾', decay: effect.decay_percent, turns: 99 });
                    GameState.addLog(`${attacker.name} 獲得 ${effect.shield} 衰減護盾`, 'skill');
                    break;
                case 'apply_erosion':
                    defender.statusEffects.push({ type: 'erosion', name: '侵蝕', hp_percent: effect.hp_percent, atk_percent: effect.atk_percent, turns: effect.turns });
                    GameState.addLog(`${defender.name} 受到侵蝕`, 'skill');
                    break;
                case 'transform_chance':
                    if(await Animations.probabilityRoll(effect.chance, '變形判定')) {
                        await this.evolveCharacter(attacker, effect.target);
                    }
                    break;
                case 'lifesteal_next_attack':
                    attacker.nextAttackLifesteal = effect.percent;
                    GameState.addLog(`${attacker.name} 下次攻擊吸血`, 'skill');
                    break;
                case 'damage_max_hp_chance':
                    if(await Animations.probabilityRoll(effect.chance, '判定')) {
                        await this.applyDamage(attacker, defender, Math.floor(defender.maxHp * (effect.percent/100)));
                    } else {
                        await this.applyDamage(attacker, defender, effect.damage);
                    }
                    break;
                case 'suicide_damage':
                    await this.applyDamage(attacker, defender, effect.damage);
                    attacker.hp = 0;
                    GameState.addLog(`${attacker.name} 同歸於盡`, 'damage');
                    break;
                case 'transform_enemy_standby':
                    {
                        const oppState = GameState.getOpponent();
                        if (oppState.standbyCards.length > 0) {
                            const idx = Math.floor(Math.random() * oppState.standbyCards.length);
                            const oldCard = oppState.standbyCards[idx];
                            const tk = getCharacterByName(effect.target);
                            if(tk) {
                                oppState.standbyCards[idx] = createCharacterInstance(tk);
                                GameState.addLog(`對手的 ${oldCard.name} 被變成了 ${effect.target}`, 'skill');
                            }
                        }
                    }
                    break;
                case 'damage_summon_category':
                    await this.applyDamage(attacker, defender, effect.damage);
                    const smCatOwner = GameState.currentPlayer === 1 ? 'player1' : 'player2';
                    const smCat = getRandomFromCategory(effect.category);
                    if (smCat) {
                        const inst = createCharacterInstance(smCat);
                        GameState.addToStandby(smCatOwner, inst);
                        GameState.addLog(`附帶召喚了 ${inst.name}`, 'skill');
                    }
                    break;
                case 'mady_moment':
                    attacker.hp = attacker.maxHp;
                    attacker.atk += effect.atk;
                    attacker.skills.forEach(s => s.cd = 0);
                    attacker.cooldowns.fill(0);
                    GameState.addLog(`Mady時間！`, 'skill');
                    break;
                case 'apply_atheism':
                    defender.statusEffects.push({ type: 'atheism', name: '無神論', turns: effect.turns });
                    GameState.addLog(`${defender.name} 被附加無神論（無法受增益）`, 'status');
                    break;
                case 'summon_chance_scaling':
                    let curSmCh = attacker.resources.summon_chance || effect.base_chance;
                    if(await Animations.probabilityRoll(curSmCh, '召喚判定')) {
                        const targetChar = getCharacterByName(effect.target);
                        if (targetChar) {
                            const inst = createCharacterInstance(targetChar);
                            GameState.addToStandby(GameState.currentPlayer === 1 ? 'player1' : 'player2', inst);
                            GameState.addLog(`召喚了 ${inst.name}`, 'skill');
                            await Animations.drawCards([inst]);
                        }
                        attacker.resources.summon_chance = effect.base_chance;
                    } else {
                        attacker.resources.summon_chance = curSmCh + effect.increment;
                    }
                    break;
                case 'damage_enemy_max_hp_percent':
                    await this.applyDamage(attacker, defender, Math.floor(defender.maxHp * (effect.percent/100)));
                    break;
                case 'consume_believers_heal':
                    {
                        const ownerP = GameState.currentPlayer === 1 ? 'player1' : 'player2';
                        let consumed = 0;
                        GameState[ownerP].standbyCards = GameState[ownerP].standbyCards.filter(c => {
                            if(c.name === '信徒' || c.tags?.includes('believer')) { consumed++; return false; }
                            return true;
                        });
                        if (consumed > 0) {
                            attacker.hp = Math.min(attacker.maxHp, attacker.hp + consumed * effect.heal_per);
                            GameState.addLog(`獻祭了 ${consumed} 個信徒，恢復血量`, 'skill');
                        } else {
                            GameState.addLog('沒有信徒可以獻祭', 'status');
                        }
                    }
                    break;
                case 'execute_chance_or_self_damage':
                    if (await Animations.probabilityRoll(effect.chance, '判定')) {
                        defender.hp = 0;
                        GameState.addLog(`${defender.name} 被擊殺`, 'damage');
                    } else {
                        attacker.hp -= effect.self_damage;
                        GameState.addLog(`行動失敗且反噬`, 'damage');
                    }
                    break;
                case 'apply_petrify':
                    defender.statusEffects.push({ type: 'stun', name: '石化', turns: effect.turns });
                    defender.statusEffects.push({ type: 'defense_up', name: '堅硬', value: 50, turns: effect.turns });
                    GameState.addLog(`${defender.name} 被石化了`, 'skill');
                    break;
                case 'apply_allergy':
                    defender.statusEffects.push({ type: 'dot', name: '過敏', damage: effect.damage, turns: effect.turns });
                    GameState.addLog(`${defender.name} 開始過敏`, 'skill');
                    break;
                case 'consume_item_buff_atk':
                case 'consume_item_shield_heal':
                case 'consume_item_dodge':
                    const items = ['小包包', '中包包', '大包包', '超大包包'];
                    const ownerPlayerObj = GameState[GameState.currentPlayer === 1 ? 'player1' : 'player2'];
                    let itemFound = false;
                    for (let i = 0; i < ownerPlayerObj.standbyCards.length; i++) {
                        if (items.includes(ownerPlayerObj.standbyCards[i].name)) {
                            ownerPlayerObj.standbyCards.splice(i, 1);
                            itemFound = true;
                            break;
                        }
                    }
                    if (itemFound) {
                        if (effect.type === 'consume_item_buff_atk') attacker.atk += effect.atk;
                        else if (effect.type === 'consume_item_shield_heal') { attacker.shield += effect.shield; attacker.hp += effect.heal; }
                        else if (effect.type === 'consume_item_dodge') attacker.resources.dodge = (attacker.resources.dodge || 0) + effect.dodge;
                        GameState.addLog(`包包派上用場了！獲得大幅強化`, 'skill');
                    } else {
                        GameState.addLog('沒有包包可以使用', 'status');
                    }
                    break;
                case 'consume_all_summon_heal':
                    {
                        const ownerP = GameState[GameState.currentPlayer === 1 ? 'player1' : 'player2'];
                        const consumed = ownerP.standbyCards.length;
                        ownerP.standbyCards = [];
                        if (consumed > 0) {
                            attacker.hp = Math.min(attacker.maxHp, attacker.hp + consumed * effect.heal_per);
                            GameState.addLog(`吸收了所有備戰區，恢復血量`, 'skill');
                        }
                    }
                    break;
                case 'stun_self_shield':
                    defender.statusEffects.push({ type: 'stun', name: '暈眩', turns: effect.turns });
                    attacker.shield += effect.shield;
                    GameState.addLog(`暈眩對手並獲得護盾`, 'skill');
                    break;
                case 'summon_chance_once': 
                    if (await Animations.probabilityRoll(effect.chance, '召喚判定')) {
                        const targetChar = getCharacterByName(effect.target);
                        if (targetChar) {
                            const inst = createCharacterInstance(targetChar);
                            GameState.addToStandby(GameState.currentPlayer === 1 ? 'player1' : 'player2', inst);
                            GameState.addLog(`成功召喚 ${inst.name}`, 'skill');
                        }
                    }
                    break;
                case 'buff_max_hp_debuff_atk_stun':
                    attacker.maxHp += effect.max_hp;
                    attacker.hp += effect.max_hp;
                    defender.atk = Math.max(0, defender.atk - effect.debuff_atk);
                    defender.statusEffects.push({ type: 'stun', name: '暈眩', turns: effect.stun_turns });
                    GameState.addLog(`吸收能量並癱瘓對手`, 'skill');
                    break;
                case 'bonus_damage_max_hp_percent':
                    await this.applyDamage(attacker, defender, effect.base_damage + Math.floor(attacker.maxHp * (effect.percent_max_hp / 100)));
                    break;
                case 'transform_both_random':
                    {
                        const allCharsList = ALL_CHARACTERS;
                        const c1 = allCharsList[Math.floor(Math.random() * allCharsList.length)];
                        const c2 = allCharsList[Math.floor(Math.random() * allCharsList.length)];
                        const p1Obj = GameState.player1.battleCard;
                        const p2Obj = GameState.player2.battleCard;
                        if(p1Obj) await this.evolveCharacter(p1Obj, c1.name);
                        if(p2Obj) await this.evolveCharacter(p2Obj, c2.name);
                        GameState.addLog(`量子糾纏改變了現實...`, 'skill');
                    }
                    break;
                case 'set_enemy_atk_zero':
                    defender.atk = 0;
                    GameState.addLog(`${defender.name} 的攻擊力被化為0了`, 'status');
                    break;
                case 'double_atk_permanent':
                    attacker.atk *= 2;
                    GameState.addLog(`${attacker.name} 攻擊力永久翻倍！`, 'skill');
                    break;
                case 'redraw_enemy_standby':
                    {
                        const oppState = GameState.getOpponent();
                        const count = oppState.standbyCards.length;
                        oppState.standbyCards = [];
                        for(let i=0; i<count; i++){
                            const dC = drawRandomCharacter();
                            if(dC) oppState.standbyCards.push(createCharacterInstance(dC));
                        }
                        GameState.addLog(`對手的備戰區被重新洗牌了`, 'skill');
                    }
                    break;
                case 'draw_extra_if_common':
                    const pState = GameState.getCurrentPlayer();
                    const d1 = drawRandomCharacter();
                    if(d1) {
                        const inst1 = createCharacterInstance(d1);
                        pState.standbyCards.push(inst1);
                        GameState.addLog(`抽到了 ${inst1.name}`, 'skill');
                        if (inst1.rarity === 'COMMON') {
                            const d2 = drawRandomCharacter();
                            if(d2) {
                                const inst2 = createCharacterInstance(d2);
                                pState.standbyCards.push(inst2);
                                GameState.addLog(`額外抽到了 ${inst2.name}`, 'skill');
                            }
                        }
                    }
                    break;
                case 'summon_gacha_damage':
                    const gc = getRandomFromCategory(effect.category);
                    if (gc) {
                        const inst = createCharacterInstance(gc);
                        GameState.addToStandby(GameState.currentPlayer === 1 ? 'player1' : 'player2', inst);
                        GameState.addLog(`抽到了 ${inst.name}`, 'skill');
                    }
                    break;
                case 'heal_missing_hp_percent':
                    const missing = attacker.maxHp - attacker.hp;
                    attacker.hp += Math.floor(missing * (effect.percent/100));
                    break;
                case 'consume_burden_shield_damage':
                    const burden = attacker.resources.burden || 0;
                    attacker.shield += burden * effect.shield_per_burden;
                    await this.applyDamage(attacker, defender, burden * effect.damage_per_burden);
                    attacker.resources.burden = 0;
                    GameState.addLog(`引爆了所有壓力`, 'skill');
                    break;
                case 'buff_next_attack_ignore_dodge':
                    attacker.nextAttackMult = (attacker.nextAttackMult || 0) + effect.mult;
                    attacker.statusEffects.push({ type: 'ignore_dodge', name: '必中', hits: 1 });
                    GameState.addLog(`下次攻擊必中且加倍`, 'skill');
                    break;
                case 'stack_damage_reduction':
                    attacker.resources.defense_stacks = (attacker.resources.defense_stacks || 0) + effect.reduction;
                    GameState.addLog(`防禦力增加 ${effect.reduction}%`, 'skill');
                    break;
                case 'apply_sleep':
                    defender.statusEffects.push({ type: 'sleep', name: '昏睡', turns: effect.turns || 99 });
                    GameState.addLog(`${defender.name} 被施加催眠`, 'skill');
                    break;
                case 'whip_strike':
                    await this.applyDamage(attacker, defender, effect.damage);
                    if(await Animations.probabilityRoll(effect.chance, '判定')) {
                        defender.statusEffects.push({ type: 'stun', name: '暈眩', turns: 1 });
                        GameState.addLog(`附加了暈眩`, 'skill');
                    }
                    break;
                case 'apply_anxiety':
                    defender.statusEffects.push({ type: 'anxiety', name: '焦慮', turns: effect.turns });
                    GameState.addLog(`${defender.name} 陷入焦慮`, 'skill');
                    break;
                case 'execute_if_hp_below_percent':
                    if (defender.hp <= defender.maxHp * (effect.percent / 100)) {
                        defender.hp = 0;
                        GameState.addLog(`${defender.name} 遭到斬殺！`, 'damage');
                    } else {
                        GameState.addLog(`血量過高，無法斬殺`, 'status');
                    }
                    break;
                case 'add_dodge':
                    attacker.resources.dodge = (attacker.resources.dodge || 0) + effect.value;
                    break;
                case 'multiply_atk':
                    attacker.atk = Math.floor(attacker.atk * effect.mult);
                    GameState.addLog(`攻擊力變為 ${effect.mult} 倍！`, 'skill');
                    break;
                case 'apply_excite':
                    defender.statusEffects.push({ type: 'excite', name: '亢奮', turns: effect.turns });
                    GameState.addLog(`${defender.name} 陷入亢奮狀態`, 'skill');
                    break;
                case 'stack_defense_dodge':
                    attacker.resources.dodge = (attacker.resources.dodge || 0) + effect.dodge;
                    attacker.resources.defense_stacks = (attacker.resources.defense_stacks || 0) + effect.reduction;
                    break;
