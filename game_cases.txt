            // --- PART 5 & 6 PASSIVE EFFECTS ---
            case 'check_mahjong_combo':
                if (trigger === 'on_turn_start' || trigger === 'passive') {
                    const ownerP = this.player1.battleCard === card || this.player1.standbyCards.includes(card) ? 'player1' : 'player2';
                    const sb = this[ownerP].standbyCards;
                    if(effect.combo === '大三元') {
                        const required = ['紅中', '青發', '白板'];
                        if(required.every(name => sb.some(c => c.name === name)) && !card.resources.combo_triggered) {
                            card.atk += effect.atk;
                            card.maxHp += effect.max_hp;
                            card.hp += effect.max_hp;
                            card.resources.combo_triggered = true;
                        }
                    } else if (effect.combo === '大四喜') {
                        const required = ['東風', '南風', '西風', '北風'];
                        if(required.every(name => sb.some(c => c.name === name)) && !card.resources.combo_triggered) {
                            card.atk += effect.atk;
                            card.maxHp += effect.max_hp;
                            card.hp += effect.max_hp;
                            card.resources.combo_triggered = true;
                        }
                    } else if (effect.combo === '十七張') {
                        if (this[ownerP].allCards && this[ownerP].allCards.length >= 17 && !card.resources.combo_triggered) {
                            card.atk += effect.atk;
                            card.maxHp += effect.max_hp;
                            card.hp += effect.max_hp;
                            card.resources.combo_triggered = true;
                        }
                    }
                }
                break;
            case 'bao_passive':
                if (trigger === 'on_turn_start') {
                    card.resources[effect.resource_name] = (card.resources[effect.resource_name] || 0) + 1;
                    if (card.resources[effect.resource_name] % effect.threshold === 0) {
                        card.atk += effect.atk;
                        this.addLog(`${card.name} 成長了！ATK +${effect.atk}`, 'skill');
                    }
                }
                break;
            case 'reject_clone':
                if (trigger === 'on_enter' || trigger === 'passive') {
                    const opp = this.getOpponent().battleCard;
                    if (opp && opp.name === card.name && opp !== card) {
                        opp.hp = 0;
                        this.addLog(`世上不需要兩個${card.name}！`, 'damage');
                    }
                }
                break;
            case 'check_hollow_purple':
                if (trigger === 'on_turn_start' || trigger === 'passive') {
                    const ownerP = this.player1.battleCard === card || this.player1.standbyCards.includes(card) ? 'player1' : 'player2';
                    const sb = this[ownerP].standbyCards;
                    if (sb.some(c => c.name === effect.requires[0]) && sb.some(c => c.name === effect.requires[1]) && !card.resources.hollow_purple) {
                        card.skills[0].effect = { type: 'damage', value: effect.damage };
                        card.skills[0].name = '虛式「茈」';
                        card.resources.hollow_purple = true;
                        this.addLog(`${card.name} 領悟了 虛式「茈」！`, 'skill');
                    }
                }
                break;
            case 'refresh_cooldowns':
                if (trigger === 'on_turn_start' && Math.random()*100 < effect.chance) {
                    card.cooldowns.fill(0);
                    this.addLog(`${card.name} 重置了所有技能冷卻！`, 'skill');
                }
                break;
            case 'damage_cap':
                if (trigger === 'passive') {
                    card.statusEffects = card.statusEffects.filter(e => e.type !== 'damage_cap_hit');
                    card.statusEffects.push({ type: 'damage_cap_hit', cap: effect.value, hits: 99 });
                }
                break;
            case 'set_atk':
                if (trigger === 'on_skill_success') {
                    card.atk = effect.value;
                }
                break;
            case 'bonus_vs_character':
                if (trigger === 'on_attack') {
                    const opp = this.getOpponent().battleCard;
                    if (opp && opp.name.includes(effect.target)) {
                        opp.hp -= effect.damage;
                        this.addLog(`針對性攻擊！附加 ${effect.damage} 傷害`, 'damage');
                    }
                }
                break;
            case 'breakthrough':
                if (trigger === 'on_attack') {
                    const opp = this.getOpponent().battleCard;
                    if (opp && opp.resources && opp.resources.defense_stacks) {
                        opp.resources.defense_stacks = 0;
                    }
                    if (opp && opp.shield > 0) {
                        opp.shield = 0;
                        this.addLog(`破壞了護盾與防禦！`, 'skill');
                    }
                }
                break;
            case 'robot_merge':
                if (trigger === 'on_turn_start' || trigger === 'passive') {
                    const ownerP = this.player1.battleCard === card || this.player1.standbyCards.includes(card) ? 'player1' : 'player2';
                    const sb = this[ownerP].standbyCards;
                    const r1 = sb.findIndex(c => c.name === effect.requires[0]);
                    const r2 = sb.findIndex(c => c.name === effect.requires[1]);
                    const r3 = sb.findIndex(c => c.name === effect.requires[2]);
                    if (r1 !== -1 && r2 !== -1 && r3 !== -1) {
                        const indices = [r1, r2, r3].sort((a,b)=>b-a);
                        indices.forEach(idx => sb.splice(idx, 1));
                        
                        // We will rely on window.BattleSystem in browser, we can't import dynamically in synchronous.
                        // Wait, processPassive does not have BattleSystem? ProcessPassive is in GameState. In game, BattleSystem is global.
                        if (typeof BattleSystem !== 'undefined') {
                            BattleSystem.evolveCharacter(card, effect.target); 
                        } else {
                            const tChar = getCharacterByName(effect.target);
                            Object.assign(card, createCharacterInstance(tChar));
                            this.addLog(`${card.name} 合體完成！`, 'skill');
                        }
                    }
                }
                break;
            case 'death_chance_range':
                if (trigger === 'on_turn_start') {
                    if (Math.random()*100 < effect.chance) {
                        const rDmg = Math.floor(Math.random() * (effect.max_damage - effect.min_damage)) + effect.min_damage;
                        card.hp -= rDmg;
                        this.addLog(`${card.name} 突然受到 ${rDmg} 傷害`, 'damage');
                    }
                }
                break;
            case 'subspace_dodge':
                if (trigger === 'passive') {
                    card.resources.dodge = effect.dodge;
                }
                break;
            case 'ignore_dodge':
                if (trigger === 'passive') {
                    if (!card.statusEffects.some(e => e.type === 'ignore_dodge')) {
                        card.statusEffects.push({ type: 'ignore_dodge', name: '必中', hits: 99 });
                    }
                }
                break;
            case 'revive_decaying_chance':
                break;
            case 'tiger_tank_wear':
                if (trigger === 'on_turn_end') {
                    card.maxHp = Math.max(1, card.maxHp - effect.hp_loss);
                    if(card.hp > card.maxHp) card.hp = card.maxHp;
                }
                break;
            case 'believer_passive':
                if (trigger === 'on_enter') {
                    const ownerP = this.player1.battleCard === card || this.player1.standbyCards.includes(card) ? 'player1' : 'player2';
                    const hasGod = this[ownerP].standbyCards.some(c => effect.gods.includes(c.name)) || (this[ownerP].battleCard && effect.gods.includes(this[ownerP].battleCard.name));
                    if (hasGod) {
                        card.atk += effect.atk;
                        card.maxHp += effect.hp;
                        card.hp += effect.hp;
                    }
                }
                break;
            case 'follower_of_believed':
                if (trigger === 'on_enter') {
                    const ownerP = this.player1.battleCard === card || this.player1.standbyCards.includes(card) ? 'player1' : 'player2';
                    const counts = this[ownerP].standbyCards.filter(c => c.name === '信徒').length;
                    card.atk += counts * effect.atk_per;
                }
                break;
            case 'shop_item':
                if (trigger === 'on_enter') {
                    card.hp = 0; 
                }
                break;
            case 'powerless':
                if (trigger === 'passive') {
                    card.atk = 0;
                }
                break;
            case 'low_hp_damage_reduction':
                if (trigger === 'passive') {
                    if (card.hp < card.maxHp * (effect.threshold/100)) {
                        card.resources.defense_stacks = effect.reduction;
                    } else {
                        card.resources.defense_stacks = 0;
                    }
                }
                break;
            case 'navy_buff':
                if (trigger === 'passive') {
                    const ownerP = this.player1.battleCard === card || this.player1.standbyCards.includes(card) ? 'player1' : 'player2';
                    const sc = this[ownerP].standbyCards.filter(c => c.name === '水軍').length;
                    if(sc > 0 && !card.resources.navy_buff_amount) {
                        card.atk += sc * effect.atk_per;
                        card.maxHp += sc * effect.hp_per;
                        card.hp += sc * effect.hp_per;
                        card.resources.navy_buff_amount = sc;
                    } else if (sc === 0 && card.resources.navy_buff_amount) {
                         const lostSc = card.resources.navy_buff_amount;
                         card.atk -= lostSc * effect.atk_per;
                         card.maxHp -= lostSc * effect.hp_per;
                         card.resources.navy_buff_amount = 0;
                    }
                }
                break;
            case 'cheater_passive':
                if (trigger === 'on_turn_end' && Math.random()*100 < effect.chance) {
                    const stolen = Math.min((this.getOpponent().battleCard?.atk || 0), effect.atk_steal);
                    if (stolen > 0) {
                        this.getOpponent().battleCard.atk -= stolen;
                        card.atk += stolen;
                        this.addLog(`作弊！偷取了 1 點攻擊力`, 'skill');
                    }
                }
                break;
            case 'transform_to':
                if (trigger === 'on_skill_count' && card.resources && card.resources.skill_count_all >= effect.skill_uses) {
                    if (typeof BattleSystem !== 'undefined') {
                        BattleSystem.evolveCharacter(card, effect.target);
                    } else {
                        const tChar = getCharacterByName(effect.target);
                        Object.assign(card, createCharacterInstance(tChar));
                    }
                }
                break;
            case 'dodge_and_reduction':
                if (trigger === 'passive') {
                    card.resources.dodge = effect.dodge;
                    card.resources.defense_stacks = effect.reduction;
                }
                break;
            case 'buff_atk_by_missing_hp':
                if (trigger === 'passive') {
                    const missing = card.maxHp - card.hp;
                    const bonus = Math.floor(missing * (effect.percent/100));
                    if(card.resources.missing_hp_bonus !== bonus) {
                        card.atk = card.atk - (card.resources.missing_hp_bonus || 0) + bonus;
                        card.resources.missing_hp_bonus = bonus;
                    }
                }
                break;
            case 'tower_shield_player_passive':
                if (trigger === 'passive') {
                }
                break;
            case 'npc_defense':
                if (trigger === 'passive') {
                    card.resources.defense_stacks = effect.reduction;
                    if (this.turnCount > 10) card.hp = 0;
                }
                break;
            case 'dodge_if_enemy_atk_high':
                if (trigger === 'passive') {
                    const opp = this.getOpponent().battleCard;
                    if(opp && opp.atk >= effect.threshold) card.resources.dodge = effect.dodge;
                    else card.resources.dodge = 0;
                }
                break;
            case 'dodge_if_enemy_anxious':
                if (trigger === 'passive') {
                    const opp = this.getOpponent().battleCard;
                    if(opp && opp.statusEffects.some(e=>e.type==='anxiety')) card.resources.dodge = effect.dodge;
                    else card.resources.dodge = 0;
                }
                break;
            case 'set_dodge':
                if (trigger === 'passive') card.resources.dodge = effect.value;
                break;
            case 'buff_atk_chance':
                if (trigger === 'on_turn_start' && Math.random()*100 < effect.chance) {
                    card.atk += effect.atk;
                }
                break;
